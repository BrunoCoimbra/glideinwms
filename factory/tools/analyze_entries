#!/usr/bin/evn python

###########################################################
# analyze_entries.py - v2.0
# created 6/10/2010, author Alison McCrea amccrea@ucsd.edu
#
# This script monitors the general status of glideins via logs, 
#    and reports the percentages of glideins 
#    failing from the following:  
# - validation problems (timeout @ 1000s),
# - 0 jobs/glidein,
# - condor startup failures, and
# - badput timeouts (1000s).
# (These are not mutually exclusive: validation problems
#      imply badput timeouts and 0 jobs/glidein already;
#      This will be addressed in later versions.)
#
# It also monitors the used and wasted walltime, and has
#     added sorting options (sort by client and by user).
#
# Planned future additions:
#   - **stats for today, yesterday, and avg of last 7 days
#   - **time used/wasted for each problem
#   - **% of total glideins making up each problem
#        (example: 23% percent of glideins failed validation)
#   - **option to sort by clients
#   - elimination of implied (repeated) problems as explained above,
#      (perhaps by prioritizing problem categories).
#   - wget failures
#   - jobs being held with Globus errors
#   - **analysis of durations
#   - subjective analysis (a few, glancable lines at the 
#         top giving an overall picture of gfactory status
#   - documentation
#
###########################################################


from __future__ import division
import os, sys, datetime, time, re, getopt
import calendar
from datetime import date

def main():

    today = time.strftime("%Y%m%d")

    usage = """
    Usage:
       
       -r [# without %] : minimum % of problematic jobs to be reported (default 50)

       [SORTING with USER/FRONTEND]
       -u : sort by users (ex: user_fecms)
       -f : sort by clients/frontends (ex: UCSD-v5_0.main) 

       [SINGLE ENTRY/USER/FRONTEND]
       -e [entry_CMS_T#_...]: check logs from this entry only
        
       [TIME INTERVALS]
       -i [mm.dd-mm.dd] : (ex: 05.28-06.05) specify an interval over which check
               logs - no whitespace (current year assumed)
       -t [hh]: [00-24] include logs that completed starting hh hours ago
       -y : check yesterday's logs only [00:00 - 23:59]

       [LOCATIONS]
       -o [abspath] : specify loc of outputted report (default ~ (user's home))
       -g [v#_#] : specify g_factory version (default v3_1)
 
       [HELP]      
       -d, -debug : print debug messages (default off)
       -h, -help : this help message
    """
       #*-ul : list users
       #*-fl : list frontends
       #*-n [-u or -f] : sort by entry (and secondarily by user or frontend)
       #*-s [username] (ex: fecms) : check logs from this user ID only
       #*-c [client] (ex:hcc-glidein-v1_0.main) : check logs from this client only
       #-l [PATH relative to home] : specify loc of gfactory (default is ../..)
       #-v : only check condor activity logs for jobs being held (no report generated)
    
    ### Defaults ###

    interval          = 0        # flag - if checking over an interval of days
    ratio             = "50"     
    hours_ago         = 0        # flag - how many hours ago to check (flag off if 0)
    yesterday         = 0        # flag - check only yesterday's logs
    check_only_one    = 0        # flag - check only one entry
    report_base       = os.path.expanduser("~")  # where report is outputted
    gfactory_version  = "v3_1"
    gfactory_location = "../.."
    debug             = 0        # flag - print debug messages
    uid               = 0        # check logs from this user id only
    frontend          = 0        # check logs from this frontend only
    sort_user         = 0
    sort_client       = 0
    sort_entry        = 0


    try:
        opts, args = getopt.getopt(sys.argv[1:], "r:i:t:ye:ho:l:g:dufc:s:"); #v");
    except getopt.GetoptError:
        print("\n Option not recognized or missing parameters.")
        print(" Use -h for usage.\n")
        sys.exit(2)
    for o, a in opts:
        if o == "-r":
            ratio = a
        elif o == "-i":
            interval = 1
            temp = a.split("-")
            temp0 = temp[0].split(".")
            temp1 = temp[1].split(".")
            # start/end date format ex: 0615
            start_date = "".join(temp0)
            end_date = "".join(temp1)
            if len(start_date) == 3: start_date = "0" + start_date
            if len(end_date) == 3: end_date = "0" + end_date
        elif o == "-t":
           hours_ago = a
        elif o == "-y":
            yesterday = 1
        elif o == "-e":
             check_only_one = 1
             only_entry = a
        elif o in ("-h", "-help"):
            print usage
            sys.exit(2)
        elif o == "-o":
            report_base = a
            if os.path.exists(os.path.abspath(a))==0:
                print "Path does not exist."
                sys.exit() 
        elif o == "-l":
            temp = a.strip("/")
            gfactory_location = temp
        elif o == "-g":
            temp = a.strip("/")
            gfactory_version = temp
        elif o in ("-d", "-debug"):
            debug = 1
            print "\nDebug mode\n"
        elif o == "-u":
            sort_user = 1 
        elif o == "-f":
            sort_client = 1
        elif o == "-n":
            sort_entry = 1
        elif o == "-s":
            uid = a
        elif o == "-c":
            frontend = a
        #elif o == "-v":
        #    activity_logs = 1
        else: 
            print("\n Option not recognized or missing parameters.")
            print(" Use -h for usage.\n")



    ###-------- Compile list of entry points to check --------###

    entry_points_location = "/home/gfactory/glideinsubmit/glidein_Production_" + gfactory_version
    os.chdir(entry_points_location)
   
    entries = []

    if(check_only_one == 1):
        entries.append(only_entry)
    
    else: 
        dir_list = os.listdir(os.getcwd()) # everything in the production folder
        dir_list_string = ','.join(dir_list)          # convert list into string deliminated by commas

        entries = re.findall("entry_[^ ,]*", dir_list_string) # list of entry points

        if debug == 1: 
            print "Looking for entries in", os.getcwd(), "..."
            print len(entries), " entries found.\n"    



    ###-------- Set interval (in which jobs complete) to check --------###

    # time variables: 
    #       dates[] (ex [13] or [21, 22, 23, 24] (for intervals) 
    #       start/end_time (ex 20100613055419), 
    #       start/end_date (ex 20100613), 
    #       job_start/end_time ('terminated="2010-06-13T05:54:19-7:00"')

    now = time.strftime("%Y%m%d%H%M%S")

    #if several hours back:
    if int(hours_ago) != 0:
       
        # if hours_ago > hours that have occured today, go into yesterday
        # (Only works up to 24 hours ago)
        now_hour = time.strftime("%H")
        if(int(hours_ago) > int(now_hour)): 
           start_time = str(int(now) - ((76 + int(hours_ago))  * 10000))

        else:
           start_time = str(int(now) - (int(hours_ago) * 10000))

        end_time = now

    #if yesterday 
    elif yesterday == 1:
        start_time = (str(int(today)-1) + "000000")
        end_time = str(int(today)-1) + "235959"
         
 
    #if interval
    elif interval == 1:
        start_time =  "2010" + start_date + "000000"
        end_time = "2010" + end_date + "000000"

    #if only today
    else:
        start_time = today+"000000"   #start time = midnight
        end_time = now

    start_date = start_time[0:8]
    end_date = end_time[0:8]

    if debug == 1: print "Start Date = ", start_date, "\nEnd Date =   ", end_date
    if debug == 1: print "Start Time = ", start_time, "\nEnd Time =   ", end_time

    # list of dates over which to check completed_jobs logs
    dates = [start_date]

    start_month = start_date[4:6]
    end_month = end_date[4:6]
    start_day = start_date[6:8]
    end_day = end_date[6:8]

    ## Month-spanning intervals ##

    if interval == 1:
        if start_date > end_date:
            print "Staring date is greater than ending date!"
            sys.exit()

        if start_date > today or end_date > today:
            print "Date out of Range."
            sys.exit()

        # if same month, append the dates between the start and end dates
        days_in_month = calendar.monthrange(2010, int(start_month))[1]
        if int(start_month) == int(end_month):
            for i in range(days_in_month):
                if i > int(start_day) and i <= int(end_day):
                    if i < 10: dates.append("2010"+start_month+"0"+str(i))
                    else: dates.append("2010"+start_month+str(i))

        else: # If different months, add last days of initial month
            if int(start_month) != int(end_month):
                for i in range(days_in_month):
                    if i > int(start_day):
                        if i < 10: dates.append("2010"+start_month+"0"+str(i))
                        else: dates.append("2010"+start_month+str(i)) 
                if start_month < 9:
                    start_month = "0" + str(int(start_month) + 1)
                else: start_month = str(int(start_month) + 1)

            # while there is still a month difference, add all the dates in that month
            while(int(start_month) != int(end_month)):
                days_in_month = calendar.monthrange(2010, int(start_month))[1]
                for i in range(days_in_month):
                    if i < 10: dates.append("2010"+start_month+"0"+str(i))
                    else: dates.append("2010"+start_month+str(i))
                if int(start_month) < 9:
                    start_month = "0" + str(int(start_month) + 1)
                else: start_month = str(int(start_month) + 1)
    
            # when while loop exits, months should be the same, 
            #      so the rest of the final month's dates can be added.   
            days_in_month = calendar.monthrange(2010, int(start_month))[1]
            for i in range(days_in_month):
                if i <= int(end_day):
                    if i < 10: dates.append("2010"+start_month+"0"+str(i))
                    else: dates.append("2010"+start_month+str(i))
    if debug == 1: print "Dates: ", dates


    # Format start and end times in job-time format ("YYYY-MM-DDThh:mm:ss-7:00")
    a = start_time
    b = end_time
    job_start_time1 = a[0:4]+"-"+a[4:6]+"-"+a[6:8]+"T"+a[8:10]+":"+a[10:12]+":"+a[12:14]
    job_start_time = "terminated=\"" + job_start_time1 + "-07:00\""
    job_end_time1 = b[0:4]+"-"+b[4:6]+"-"+b[6:8]+"T"+b[8:10]+":"+b[10:12]+":"+b[12:14]
    job_end_time = "terminated=\"" + job_end_time1 + "-07:00\""
    if debug == 1: print "job_start: %s, job end %s.\n" % (job_start_time, job_end_time)



    ###----- Start collecting data -----###

    #May need to grab from client_log directory instead 
    os.chdir("client_log")
    users = os.listdir(os.getcwd())
    if debug == 1: print users
    # need user_fesleep?
    
    os.chdir("../log")

    # total-so-far dictionaries (ones to be presented at end)
    # ex: condor_start_d = {entry_1: bad-total; entry 2: 124-100; ...}
    condor_start_d = {}
    validation_d = {}
    jobsnr_d = {}
    badput_d = {}
    duration_d = {}
    client_d = {}
    username_d = {} 

    user_jobs = {}
    client_jobs = {}
    #for i in users:
    #    i = [condor_start_d, validation_d, jobsnr_d, badput_d]
    #    user_list.append(i)
    
    total_glideins = 0
    total_jobs = 0
    time_used = 0 
    time_wasted = 0

    client_glidein_total = {}
    user_glidein_total = {}

    for e in entries:
        
        joblist = []

        if debug == 1: print "Checking " + e +  "...",

        if os.path.exists(e):
            os.chdir(e)
        else:
            print "Entry does not exist."
            sys.exit()

        for d in dates:
            c = "completed_jobs_" + d + ".log"
            if os.path.isfile(c) == 0:
               continue
            f = open(c, 'r')
            jobs = (f.read()).split("\n")
 
            # have list of all jobs:
            # for interval/hours_ago, remove jobs out of time range
            # but need termination time first

            # make list of termination times:
            for j in jobs:
                if len(j) != 0: 
                    term_time = re.findall('terminated=\"\S*\"', j) 
                    if ((interval == 1 or hours_ago != 0) and len(term_time) > 0):
                        if ((term_time[0] > job_start_time) or (term_time[0] < job_end_time)):
                            joblist.append(j)
                    else: 
                        joblist.append(j)

        total_glideins = total_glideins + len(joblist)           
 
        #if debug == 1: print "job count = ", len(joblist)  
        if len(joblist) == 0: 
            os.chdir("..")
            if debug == 1: print "No jobs."
            continue        
         
        # Have job list with specific jobs,
        #    now search for problems.
        
        # these lists have specific params we need to keep track of.
        ids = []
        term_times = []
        durations = []
        clients = []
        usernames = []
        goodput = []
        
        # these lists contain only the problematic sites; 
        #    for example only the sites where badput = 1000 or jobs = 0.
        condor_start_total = []   # badput = 1000
        jobsnr_total = []         # jobs_nr = 0
        validation_total = []     # validation = 1000
        badput_total = []         # badput = 1000

        # Lists of attributes for all glideins (id = [52334, 14614, ...]]
        totals_list = [ids, term_times, durations, condor_start_total, 
                           jobsnr_total, validation_total, goodput, 
                                              badput_total, clients, usernames]
        
        total_re_list = ['id=\"\d{5}.\d{3}\"', 'terminated=\"\S*\"', 'duration=\"\d*\"', 
                         'condor_started=\"(False|True)\"', 'jobsnr=\"\d*\"', 
                         'validation=\"\d*\"','goodput=\"\d*\"','badput=\"\d*\"',
                         'client=\"\S*\"','username=\"\S*\"']

        # Lists of all glideins (condor_start_total = ["False", "True",...])
        list_list = [condor_start_total, validation_total, 
                     jobsnr_total,   badput_total]

        dictionary_list = [condor_start_d, validation_d, jobsnr_d, badput_d]
        problem_re_list = ["False", "1000", "0", "1000"]
        #print "\n\n\njoblist count for", e, "=", len(joblist)
        temp5 = 0
        for j in joblist:
            for i in range(len(totals_list)):
               temp = re.findall(total_re_list[i], j)
               if len(temp) > 0: 
                   totals_list[i].append(temp[0])

            if sort_client == 1:
                job_client = ''.join(re.findall('client=\"\S*\"',j))
                job_client = (job_client.lstrip("client=\"")).rstrip("\"")
                # ex. j_client/user = user_fecms; the client/user of this single job
                # add this job to it's user/client's dictionary
                
                # job client checked and correct
                if job_client not in client_jobs:
                    client_jobs[job_client]= {}
                if e not in client_jobs[job_client]:
                    client_jobs[job_client][e] = []
                client_jobs[job_client][e].append(j)

                # add 1 to this job's client's glidein count
                if job_client not in client_glidein_total:
                    client_glidein_total[job_client] = 0
                client_glidein_total[job_client] += 1
    

            if sort_user == 1:
                job_user = ''.join(re.findall('username=\"\S*\"',j))
                job_user = (job_user.lstrip("username=\"")).rstrip("\"")
                # ex. j_client/user = user_fecms; the client/user of this single job
                # add this job to it's user/client's dictionary
                
                # job client checked and correct
                if job_user not in user_jobs:
                    user_jobs[job_user]= {}
                if e not in user_jobs[job_user]:
                    user_jobs[job_user][e] = []
                user_jobs[job_user][e].append(j)

                # add 1 to this job's user's glidein count
                if job_user not in user_glidein_total:
                    user_glidein_total[job_user] = 0
                user_glidein_total[job_user] += 1

        # total number of jobs
        for i in jobsnr_total:
            temp = re.findall("\d*",i)
            temp2 = ''.join(temp)
            total_jobs = total_jobs + int(temp2)
        # total cpu time utilized
        for i in goodput:
            temp = re.findall("\d*",i)
            temp2 = ''.join(temp)
            time_used = time_used + int(temp2)
        # total cpu time wasted
        for i in badput_total:
            temp = re.findall("\d*",i)
            temp2 = ''.join(temp)
            time_wasted = time_wasted + int(temp2)
        
        # for each list, count the matched corresponding regexes, calculate
        #     the ratio (problematic:good), and add to total dictionary
        #     under this entry (ex. validation = {entry_1: "50/300", ...}
        count = 0
        for j in range(len(list_list)):
            count = 0
            for i in list_list[j]:
                temp = re.findall(problem_re_list[j], i)
             #   if e == "entry_CMS_T2_ES_CIEMAT_lcg02":
              #      print i, "\n\n"
               #     print temp, "\n\n"
                count = count + len(temp)
                r = str(int(count/len(list_list[j])*100))
                total = str(len(list_list[j]))
            # ratio - total, ex: "56-200" = 56% of 200
            (dictionary_list[j])[e] = r + "-" + total  


        os.chdir("..")

    ###------------------- Make Report -------------------###
   
    if check_only_one == 1: 
        ent = ":" + only_entry
        ent2 = ent
    else: 
        ent = ""
        ent2 = "All Entries"
    a = start_time
    b = end_time
 
    if(interval == 1 or hours_ago != 0):
       title_start_time = a[4:6]+"."+a[6:8]+"_"+a[8:10]+":"+a[10:12]+"-"
       title_end_time = b[4:6]+"."+b[6:8]+"_"+b[8:10]+":"+b[10:12]
    else:
       title_start_time = a[4:6]+"-"+a[6:8]+"-"+a[0:4]
       title_end_time = ''
       if yesterday == 0: title_end_time = "_" + time.strftime("%H:%M:%S")  
    report_name = "log_" + title_start_time + title_end_time + ent 

    os.chdir(os.path.abspath(report_base))
    
    report = open(report_name, 'w')
    report.write("""
Glidein log analysis for %s, for %s%s 
----------------------------------------
Total Glideins: %s
Total Jobs: %s (Average jobs/glidein: %.2f) 

Total CPU time used: %s s (%.1f hours)
Total CPU time wasted: %s s (%.1f hours)
Time used/time wasted: %.2f
CPU time efficiency: %.2f
-----------------------------------------
""" % (ent2,title_start_time,title_end_time,total_glideins,total_jobs,
      (total_jobs/total_glideins), time_used, (time_used/3600), time_wasted, 
      time_wasted/3600,time_used/time_wasted,time_used/(time_used+time_wasted)))


    ## ---- Main Report Format --------------------- ##

    # for each dictionary, print out the culprits who exceed ratio r.
    # (dictionary_list = [condor_start_d, jobsnr_d, validation_d, badput_d])
    desc_list = ["Condor startup failure:\n","Validation problems:\n",
                 "0 jobs per glidein\n", "No goodput:\n"]   
    
    if sort_client == 0 and sort_user == 0:

        report.write("Percentage (> %s%%) of glideins which have:\n" % ratio)    

        # dictionary list of entries = {entry 1: list_of_all_params; ...}  
        for j in range(len(dictionary_list)): # for each entry

            to_be_printed = []
            category_tot = 0
            tot = ''
            # for each piece of the dictionary
            #         (entry1, val) or (entry1, badput)
            for a,b in dictionary_list[j].iteritems():
                r = (re.findall("\d+\-",b)[0]).strip("-")
                tot = (re.findall("\-\d+",b)[0]).strip("-")
                if int(r) >= int(ratio):
                    to_be_printed.append("%-50s %s%% / %s\n" % (a, r, tot))
                    category_tot = category_tot + (int(r)/100)*int(tot)
        
            category_percentage = category_tot/total_glideins

            report.write("\n%s(%s glideins - %.2f%% of total)\n\n" 
                   % (desc_list[j], category_tot, category_percentage*100))

            for i in to_be_printed:
                report.write(i)
            report.write( "-----------------------------------\n" )


    ## ---- User/Client-Sort Report Format --------------------- ##

    else:

        #change users list based on -u or -f options
        if sort_user or sort_client == 1:

            if sort_user == 1:
                report.write( "\nSorting by user.\n\n")
            if sort_client == 1:
                report.write( "\nSorting by client.\n\n")

            final_dictionary = {}

            if sort_user == 1:
                final_dictionary = user_jobs
                sort_glidein_total = user_glidein_total

            elif sort_client == 1:
                final_dictionary = client_jobs
                sort_glidein_total = client_glidein_total


            for clientuser, entry_dict in final_dictionary.iteritems():

                report.write( "%-39s %4s %4s %5s %5s %6s %6s %9s\n" % 
                     (clientuser,"start","val","0job","badp","waste","time","total"))

                report.write( "%.2f glideins - %.2f%% of total\n\n" 
                     % (sort_glidein_total[clientuser], sort_glidein_total[clientuser]/total_glideins*100))

                for entry, job_list in entry_dict.iteritems():

                     
                    report.write( "%-39s" % entry ),
           
                    total = len(job_list)
                    bad_start_count = 0
                    bad_val_count = 0
                    bad_0jobs_count = 0
                    bad_badput_count = 0
                    entry_time_wasted = 0
                    entry_time_total = 0
                        
                    for job in job_list:
                        start_list = re.findall('False',job)
                        if len(start_list) != 0:
                            bad_start_count += 1

                        val_list = re.findall('validation="\d+"',job)
                        val = re.findall("\d+", ",".join(val_list))
                        if val[0] == "1000":
                            bad_val_count += 1

                        jobsnr_list = re.findall('jobsnr="\d+"',job)
                        jobsnr = re.findall("\d+", ",".join(jobsnr_list))
                        if jobsnr[0] == "0":
                            bad_0jobs_count += 1

                        badput_list = re.findall('badput="\d+"',job)
                        badput = re.findall("\d+", ",".join(badput_list))
                        if badput[0] == "1000":
                            bad_badput_count += 1

                        wasted_list = re.findall('badput="\d+"',job)
                        badput = re.findall("\d+", ",".join(wasted_list))
                        entry_time_total = entry_time_total + int(badput[0])
                        entry_time_wasted = entry_time_wasted + int(badput[0])

                        used_list = re.findall('goodput="\d+"',job)
                        goodput = re.findall("\d+", ",".join(used_list))
                        entry_time_total = entry_time_total + int(goodput[0])

                    report.write( "%4s  %4s  %4s  %4s  %6.1f  %6.1f  %1s  %3s\n" % (
                                str(int((bad_start_count/len(job_list)*100)))+"%",
                    		str(int((bad_val_count/len(job_list)*100)))+"%",
                    		str(int((bad_0jobs_count/len(job_list)*100)))+"%",
                    		str(int((bad_badput_count/len(job_list)*100)))+"%",
                    	        entry_time_wasted/3600,	
                    		entry_time_total/3600,
                                "|",
                                len(job_list)))

                report.write( "--------------------------------------\n")       

        report.write("""
KEY:

start = condor failed to start
val = failed to validate (hit 1000s limit)
0jobs = 0 jobs/glidein
badput = badput timeout (1000s)
wasted = wallclock time wasted (hours)
time = total wallclock time (hours)
total = total number of glideins
-------------------------------------
        \n""")

    print "\n" + report_name + " output to " + report_base + ".\n"
    


if __name__ == "__main__":
    main()

