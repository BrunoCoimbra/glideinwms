#!/usr/local/bin/python

###########################################################
# analyze_entries_v1.py
# created 6/10/2010, author Alison McCrea amccrea@ucsd.edu
#
# This script monitors the general status of glideins via logs, 
#    and reports the percentages of glideins 
#    failing from the following:  
# - validation problems (timeout @ 1000s),
# - 0 jobs/glidein,
# - condor startup failures, and
# - badput timeouts (1000s).
# (These are not mutually exclusive: validation problems
#      imply badput timeouts and 0 jobs/glidein already;
#      This will be addressed in later versions.)
#
# Planned future additions:
#   - **stats for today, yesterday, and avg of last 7 days
#   - **time used/wasted for each problem
#   - **% of total glideins making up each problem
#        (example: 23% percent of glideins failed validation)
#   - **option to sort by clients
#   - elimination of implied (repeated) problems as explained above,
#      (perhaps by prioritizing problem categories).
#   - wget failures
#   - jobs being held with Globus errors
#   - **analysis of durations
#   - subjective analysis (a few, glancable lines at the 
#         top giving an overall picture of gfactory status
#   - documentation
#
###########################################################


from __future__ import division
import os, sys, datetime, time, re, getopt
import calendar
from datetime import date

def main():

    today = time.strftime("%Y%m%d")

    usage = """
    Usage:
       -r [# without %] : minimum % of problematic jobs to be reported (default 50)
       -i [mm.dd-mm.dd] : (ex: 05.28-06.05) specify an interval over which check
               logs - no whitespace (current year assumed)
       -t [hh]: [00-24] include logs that completed starting hh hours ago
       -y : check yesterday's logs only [00:00 - 23:59]
       -e [entry_CMS_T#_...]: check logs from this entry only
       -h, -help : this help message
       -o [abspath] : specify loc of outputted report (default ~)
       -g [v#_#] : specify g_factory version (default v3_1)
       -d, -debug : print debug messages (default off)
       -u [username (UID)] (ex: fecms) : check logs from this user ID only
       -f [frontend] (ex:hcc-glidein-v1_0.main) : check logs from this frontend only 
    """
       #-l [PATH relative to home] : specify loc of gfactory (default is ../..)
       #-v : only check condor activity logs for jobs being held (no report generated)
    
    ### Defaults ###

    interval          = 0        # flag
    ratio             = "50"
    hours_ago         = 0
    yesterday         = 0        # flag
    check_only_one    = 0        # flag
    report_base       = os.path.expanduser("~")  
    gfactory_version  = "v3_1"
    gfactory_location = "../.."
    debug             = 0        # flag
    uid               = "0"
    frontend          = "0"
    #activity_logs     = 0

    try:
        opts, args = getopt.getopt(sys.argv[1:], "r:i:t:ye:ho:l:g:d"); #v");
    except getopt.GetoptError:
        print("\n Option not recognized or missing parameters.")
        print(" Use -h for usage.\n")
        sys.exit(2)
    for o, a in opts:
        if o == "-r":
            ratio = a
        elif o == "-i":
            interval = 1
            temp = a.split("-")
            temp0 = temp[0].split(".")
            temp1 = temp[1].split(".")
            # start/end date format ex: 0615
            start_date = "".join(temp0)
            end_date = "".join(temp1)
            if len(start_date) == 3: start_date = "0" + start_date
            if len(end_date) == 3: end_date = "0" + end_date
        elif o == "-t":
           hours_ago = a
        elif o == "-y":
            yesterday = 1
        elif o == "-e":
             check_only_one = 1
             only_entry = a
        elif o in ("-h", "-help"):
            print usage
            sys.exit(2)
        elif o == "-o":
            report_base = a
            if os.path.exists(os.path.abspath(a))==0:
                print "Path does not exist."
                sys.exit() 
        elif o == "-l":
            temp = a.strip("/")
            gfactory_location = temp
        elif o == "-g":
            temp = a.strip("/")
            gfactory_version = temp
        elif o in ("-d", "-debug"):
            debug = 1
            print "\nDebug mode\n"
        elif o == "-u":
            uid = a
        elif o == "-f":
            frontend = a
        #elif o == "-v":
        #    activity_logs = 1
        else: 
            print("\n Option not recognized or missing parameters.")
            print(" Use -h for usage.\n")

    ###-------- Compile list of entry points to check --------###

    entry_points_location = "/home/gfactory/glideinsubmit/glidein_Production_" + gfactory_version
    os.chdir(entry_points_location)
   
    entries = []

    if(check_only_one == 1):
        entries.append(only_entry)
    
    else: 
        dirlist = os.listdir(os.getcwd()) # everything in the production folder
        delim = ","                         # deliminator
        dir2 = delim.join(dirlist)          # convert list into string deliminated by commas

        entries = re.findall("entry_[^ ,]*", dir2) # list of entry points

        if debug == 1: 
            print "Looking for entries in", os.getcwd(), "..."
            print len(entries), " entries found.\n"    
            #print "List of entries to check: ", entries          

    ###-------- Set interval (in which jobs complete) to check --------###

    # time variables: 
    #       dates[] (ex [13] or [21, 22, 23, 24] (for intervals) 
    #       start/end_time (ex 20100613055419), 
    #       start/end_date (ex 20100613), 
    #       job_start/end_time ('terminated="2010-06-13T05:54:19-7:00"')

    now = time.strftime("%Y%m%d%H%M%S")

    #if several hours back:
    if int(hours_ago) != 0:
       
        # if hours_ago > hours that have occured today, go into yesterday
        # (Only works up to 24 hours ago)
        now_hour = time.strftime("%H")
        if(int(hours_ago) > int(now_hour)): 
           start_time = str(int(now) - ((76 + int(hours_ago))  * 10000))

        else:
           start_time = str(int(now) - (int(hours_ago) * 10000))

        end_time = now

    #if yesterday 
    elif yesterday == 1:
        start_time = (str(int(today)-1) + "000000")
        end_time = str(int(today)-1) + "235959"
         
 
    #if interval
    elif interval == 1:
        start_time =  "2010" + start_date + "000000"
        end_time = "2010" + end_date + "000000"

    #if only today
    else:
        start_time = today+"000000"   #start time = midnight
        end_time = now

    start_date = start_time[0:8]
    end_date = end_time[0:8]

    if debug == 1: print "Start Date = ", start_date, "\nEnd Date =   ", end_date
    if debug == 1: print "Start Time = ", start_time, "\nEnd Time =   ", end_time

    # list of dates over which to check completed_jobs logs
    dates = [start_date]

    start_month = start_date[4:6]
    end_month = end_date[4:6]
    start_day = start_date[6:8]
    end_day = end_date[6:8]

    ## Month-spanning intervals ##

    if interval == 1:
        if start_date > end_date:
            print "Staring date is greater than ending date!"
            sys.exit()

        if start_date > today or end_date > today:
            print "Date out of Range."
            sys.exit()

        # if same month, append the dates between the start and end dates
        days_in_month = calendar.monthrange(2010, int(start_month))[1]
        if int(start_month) == int(end_month):
            for i in range(days_in_month):
                if i > int(start_day) and i <= int(end_day):
                    if i < 10: dates.append("2010"+start_month+"0"+str(i))
                    else: dates.append("2010"+start_month+str(i))

        else: # If different months, add last days of initial month
            if int(start_month) != int(end_month):
                for i in range(days_in_month):
                    if i > int(start_day):
                        if i < 10: dates.append("2010"+start_month+"0"+str(i))
                        else: dates.append("2010"+start_month+str(i)) 
                if start_month < 9:
                    start_month = "0" + str(int(start_month) + 1)
                else: start_month = str(int(start_month) + 1)

            # while there is still a month difference, add all the dates in that month
            while(int(start_month) != int(end_month)):
                days_in_month = calendar.monthrange(2010, int(start_month))[1]
                for i in range(days_in_month):
                    if i < 10: dates.append("2010"+start_month+"0"+str(i))
                    else: dates.append("2010"+start_month+str(i))
                if int(start_month) < 9:
                    start_month = "0" + str(int(start_month) + 1)
                else: start_month = str(int(start_month) + 1)
    
            # when while loop exits, months should be the same, 
            #      so the rest of the final month's dates can be added.   
            days_in_month = calendar.monthrange(2010, int(start_month))[1]
            for i in range(days_in_month):
                if i <= int(end_day):
                    if i < 10: dates.append("2010"+start_month+"0"+str(i))
                    else: dates.append("2010"+start_month+str(i))
    if debug == 1: print "Dates: ", dates


    # Format start and end times in job-time format ("YYYY-MM-DDThh:mm:ss-7:00")
    a = start_time
    b = end_time
    job_start_time1 = a[0:4]+"-"+a[4:6]+"-"+a[6:8]+"T"+a[8:10]+":"+a[10:12]+":"+a[12:14]
    job_start_time = "terminated=\"" + job_start_time1 + "-07:00\""
    job_end_time1 = b[0:4]+"-"+b[4:6]+"-"+b[6:8]+"T"+b[8:10]+":"+b[10:12]+":"+b[12:14]
    job_end_time = "terminated=\"" + job_end_time1 + "-07:00\""
    if debug == 1: print "job_start: %s, job end %s.\n" % (job_start_time, job_end_time)

    ###----- Start collecting data -----###

    #May need to grab from client_log directory instead 
    os.chdir("client_log")
    users = os.listdir(os.getcwd())
    # need user_fesleep?
    
    os.chdir("../log")

    # total-so-far dictionaries (ones to be presented at end)
    # ex: condor_start_d = {entry_1: bad-total; entry 2: 124-100; ...}
    condor_start_d = {}
    jobsnr_d = {}
    validation_d = {}
    badput_d = {}
    duration_d = {} 

    total_glideins = 0
    total_jobs = 0
    time_used = 0 
    time_wasted = 0

    for e in entries:

        joblist = []

    # Turn this back on later
    #    if debug == 1: print "Checking " + e +  "..."

        if os.path.exists(e):
            os.chdir(e)
        else:
            print "Entry does not exist."
            sys.exit()

        for d in dates:
            c = "completed_jobs_" + d + ".log"
            if os.path.isfile(c) == 0:
               continue
            f = open(c, 'r')
            jobs = (f.read()).split("\n")
 
            # have list of all jobs:
            # for interval/hours_ago, remove jobs out of time range
            # but need termination time first

            # make list of termination times:
            for j in jobs:
                if len(j) != 0: 
                    term_time = re.findall('terminated=\"\S*\"', j) 
                    if ((interval == 1 or hours_ago != 0) and len(term_time) > 0):
                        if ((term_time[0] > job_start_time) or (term_time[0] < job_end_time)):
                            joblist.append(j)
                    else: joblist.append(j)
        total_glideins = total_glideins + len(joblist)           
 
        #if debug == 1: print "job count = ", len(joblist)  
        if len(joblist) == 0: 
            os.chdir("..")
            continue        
         
        # Have job list with specific jobs,
        #    now search for problems.
        
        ids = []
        term_times = []
        durations = []
        condor_start_total = []
        jobsnr_total = []
        validation_total = []
        goodput_total = []
        badput_total = []
        clients = []
        usernames = []

        

        # Lists of attributes for all glideins (id = [52334, 14614, ...]]
        totals_list = [ids, term_times, durations, condor_start_total, 
                           jobsnr_total, validation_total, goodput_total, 
                                              badput_total, clients, usernames]
        
        total_re_list = ['id=\"\d{5}.\d{3}\"', 'terminated=\"\S*\"', 'duration=\"\d*\"', 
                         'condor_started=\"(False|True)\"', 'jobsnr=\"\d*\"', 
                         'validation=\"\d*\"','goodput=\"\d*\"','badput=\"\d*\"',
                         'client=\"\S*\"','username=\"\S*\"']


               
        # Lists of all glideins (condor_start_total = ["False", "True",...])
        list_list = [condor_start_total, validation_total, 
                     jobsnr_total,   badput_total]

        dictionary_list = [condor_start_d, validation_d, jobsnr_d, badput_d]
        problem_re_list = ["False", "1000", "0", "1000"]
 
        for j in joblist:
            for i in range(len(totals_list)):
               temp = re.findall(total_re_list[i], j)
               if len(temp) > 0: 
                   totals_list[i].append(temp[0])

        # total number of jobs
        for i in jobsnr_total:
            temp = re.findall("\d*",i)
            temp2 = ''.join(temp)
            total_jobs = total_jobs + int(temp2)

        # total cpu time utilized
        for i in goodput_total:
            temp = re.findall("\d*",i)
            temp2 = ''.join(temp)
            time_used = time_used + int(temp2)

        # total cpu time wasted
        for i in badput_total:
            temp = re.findall("\d*",i)
            temp2 = ''.join(temp)
            time_wasted = time_wasted + int(temp2)
        
        #print time_used, time_wasted
 
        # for each list, count the matched corresponding regexes, calculate
        #     the ratio (problematic:good), and add to total dictionary
        #     under this entry (ex. validation = {entry_1: "50/300", ...}
        
        count = 0
        
        for j in range(len(list_list)):
            count = 0
            for i in list_list[j]:
                temp = re.findall(problem_re_list[j], i)
                count = count + len(temp)
                r = str(int(count/len(list_list[j])*100))
                total = str(len(list_list[j]))
            (dictionary_list[j])[e] = r + "-" + total  

        os.chdir("..")


    ### Now we have all lists with specified jobs; make report: ### 
    if check_only_one == 1: 
        ent = ":" + only_entry
        ent2 = ent
    else: 
        ent = ""
        ent2 = "All Entries"
    a = start_time
    b = end_time
 
    if(interval == 1 or hours_ago != 0):
       title_start_time = a[4:6]+"."+a[6:8]+"_"+a[8:10]+":"+a[10:12]+"-"
       title_end_time = b[4:6]+"."+b[6:8]+"_"+b[8:10]+":"+b[10:12]
    else:
       title_start_time = a[4:6]+"-"+a[6:8]+"-"+a[0:4]
       title_end_time = ''
       if yesterday == 0: title_end_time = "_" + time.strftime("%H:%M:%S")  
    report_name = "log_" + title_start_time + title_end_time + ent 

    os.chdir(os.path.abspath(report_base))
    
    report = open(report_name, 'w')
    report.write("""
Glidein log analysis for %s, for %s%s 
----------------------------------------
Total Glideins: %s
Total Jobs: %s (Average jobs/glidein: %.2f) 

Total CPU time used: %s
Total CPU time wasted: %s
Time used/time wasted: %.2f
CPU time efficiency: %.2f

Percentage (> %s%%) of glideins which have:    
""" % (ent2,title_start_time,title_end_time,total_glideins,total_jobs,
      (total_jobs/total_glideins), time_used, time_wasted, 
      (time_used/time_wasted), time_used/(time_used+time_wasted),ratio ))

    # for each dictionary, print out the culprits who exceed ratio r.
    # (dictionary_list = [condor_start_d, jobsnr_d, validation_d, badput_d])
    desc_list = ["Condor startup failure:\n","Validation problems:\n",
                 "0 jobs per glidein\n", "No goodput:\n"]   
      
    for j in range(len(dictionary_list)):

        to_be_printed = []
        category_tot = 0
        tot = ''
        for a,b in dictionary_list[j].iteritems():
            r = (re.findall("\d+\-",b)[0]).strip("-")
            tot = (re.findall("\-\d+",b)[0]).strip("-")
            if int(r) >= int(ratio):
                to_be_printed.append("%-50s :%s%% / %s\n" % (a, r, tot))
                category_tot = category_tot + (int(r)/100)*int(tot)
        
        category_percentage = category_tot/total_glideins

        report.write("\n%s(%s glideins - %.2f%% of total glideins)\n\n" 
               % (desc_list[j], category_tot, category_percentage*100))

        for i in to_be_printed:
            report.write(i)
        report.write( "-----------------------------------\n" )


    print "\n" + report_name + " output to " + report_base + ".\n"

if __name__ == "__main__":
    main()

