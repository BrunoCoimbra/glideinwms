#!/bin/env python

import sys,os,os.path,string,time
import shutil
import tarfile,readline,pwd
import md5
import getpass
import re
import xml.sax.saxutils
import socket
import stat
import httplib
import ftplib
STARTUP_DIR=sys.path[0]
sys.path.append(os.path.join(STARTUP_DIR,"../lib"))

#############################
#
# Global variables
#
#############################

# Where is the OSG VDT client installed
VDT_BASE_PATH=None
# What port does the HTTPd listening on
HTTPD_PORT=None
# Where is RRD installed
RRD_BIN_PATH=None
# CONDOR_BASE_PATH will point to the base condor directory when condor is installed
CONDOR_BASE_PATH=None
# Where should the changes to Condor go
CONDOR_UPD_CONFIG_FILE=None
# Where is the OSG VDT client installed
VDT_BASE_PATH=None
# Has the GSI securtiy been configured
GSI_SECURITY_CONFIGURED=0
# Which port the PostgreSQL is running, if installed 
POSTGRESQL_PORT=None
# What are the passwords used for quill? (None means not configured yet)
# Will be a disctionary of reader and writer
QUILL_DB_PASSWDS=None
# Were Condor config parameters set?
QUILL_CONFIG_DONE=0
# Has the secondary support files been installed yet?
SECONDARY_SCHEDD_SUPPORT_FILES_INSTALLED=0
SECONDARY_COLLECTOR_SUPPORT_FILES_INSTALLED=0

# Was a condor collector installed on this machine?
COLLECTOR_INSTALLED=0
# Was a main schedd configured on this machine?
MAIN_SCHEDD_INSTALLED=0

##########################################
#
# Main of the intallation procedure
#
##########################################

#-------------------------------------------------------------------------------
def installer(install_options):
    print "What do you want to install?"
    print "(May select several options at one, using a , separated list)"
    opt_keys=install_options.keys()
    opt_keys.sort()
    for k in opt_keys:
        print "[%s] %s"%(k,install_options[k]["title"])

    have_valid_select=0
    while not have_valid_select:
        selected_options_str=raw_input("Please select: ")
        selected_options=selected_options_str.split(",")
        have_valid_select=1 # assume valid unless disprooved
        for s in selected_options:
            if not install_options.has_key(s):
                print "Invalid option [%s]!"%s
                have_valid_select=0 # re-ask
                break

    selected_options.sort(lambda x,y:cmp(install_options[x]["order"],(install_options[y]["order"])))

    print
    print "The following profiles will be installed:"
    for k in selected_options:
        print "[%s] %s"%(k,install_options[k]["title"])
    print
    
    for k in selected_options:
        install_options[k]["proc"]()
    return

#-------------------------------------------------------------------------------
def main():
    install_options={"1":{"title":"glideinWMS Collector",
                          "proc":wms_install,"order":13},
                     "2":{"title":"Glidein Factory",
                          "proc":gfactory_install,"order":16},
                     "3":{"title":"GCB","proc":gcb_install,"order":15}, #must be after any other condor
                     "4":{"title":"pool Collector",
                          "proc":collector_install,"order":11}, # must be before any schedd
                     "5":{"title":"Schedd node",
                          "proc":schedd_node_install,"order":12},
                     "6":{"title":"Condor for VO Frontend",
                          "proc":condor_frontend_install,"order":14},
                     "7":{"title":"VO Frontend",
                          "proc":vofrontend_install,"order":17},
                     '8':{"title":"Components",
                          "proc":main_install_components,"order":1}}
                     
    print "Welcome to the glideinWMS Installation Helper"
    print ""
    return installer(install_options)

#-------------------------------------------------------------------------------
def main_install_components():
    install_options={'a':{"title":"OSG VDT client",
                          "proc":query_vdt,"order":1},
                     'b':{"title":"Base Condor installation",
                          "proc":install_condor,"order":2}}

    if os.getuid()==0:
        install_options['c']={"title":"Web server",
                              "proc":install_httpd,"order":3}
        install_options['d']={"title":"rrdtool graphics package",
                              "proc":install_rrd,"order":4}
        install_options['e']={"title":"PostgreSQL database",
                              "proc":install_postgresql,"order":5}
        install_options['f']={"title":"Quill-specific PostgreSQL database",
                              "proc":query_quill_db,"order":6}

                     
    return installer(install_options)

##########################################
#
# Subset specific procedures
#
##########################################

#-------------------------------------------------------------------------------
def collector_install():
    global VDT_BASE_PATH
    global CONDOR_BASE_PATH
    global GSI_SECURITY_CONFIGURED
    global COLLECTOR_INSTALLED

    print "Installing pool collector"
    print

    if VDT_BASE_PATH==None:
        query_vdt()

    condor_was_installed=(CONDOR_BASE_PATH!=None)
    if CONDOR_BASE_PATH==None:
        install_condor()

    if not GSI_SECURITY_CONFIGURED:
        configure_gsi_security()

    if not COLLECTOR_INSTALLED:
        setup_collector('My pool')

    ##################################
    # configure secondary collectors
    if not SECONDARY_COLLECTOR_SUPPORT_FILES_INSTALLED:
        create_secondary_collector_support_files()
    
    while 1:
        nr_collectors_default=5
        nr_collectors_str=raw_input("How many slave collectors do you want?: [5] ")
        if nr_collectors_str=="":
            nr_collectors_str="%s"%nr_collectors_default
        try:
            nr_collectors=int(nr_collectors_str)
        except:
            print "'%s' is not a number!"%nr_collectors_str
            continue
        if nr_collectors<0:
            print "You entered a negative number! (%i)"%nr_collectors
            continue
        if nr_collectors>99: # security check
            print "You entered too big of a number! (%i)"%nr_collectors
            continue

        break # have the number of collectors

    for collector_nr in range(nr_collectors):
        configure_secondary_collector(collector_nr)

    restart_condor()

    print "**************************************************"
    print "Pool collector installation succeeded"
    print "**************************************************"
    print
    
    return

#-------------------------------------------------------------------------------
def schedd_node_install():
    global VDT_BASE_PATH
    global CONDOR_BASE_PATH
    global GSI_SECURITY_CONFIGURED
    global QUILL_CONFIG_DONE
    global SECONDARY_SCHEDD_SUPPORT_FILES_INSTALLED
    global COLLECTOR_INSTALLED
    global MAIN_SCHEDD_INSTALLED
    global CONDOR_UPD_CONFIG_FILE

    print "Installing user submit schedds"
    print

    if VDT_BASE_PATH==None:
        query_vdt()

    condor_was_installed=(CONDOR_BASE_PATH!=None)
    if CONDOR_BASE_PATH==None:
        install_condor()

    if not GSI_SECURITY_CONFIGURED:
        configure_gsi_security()

    if not QUILL_CONFIG_DONE:
        yn=raw_input("Do you want to Use Quill (works for 6.8.X only)?: (y/n) [n]")
        if yn=='y':
            setup_quill()

    if not MAIN_SCHEDD_INSTALLED:
        setup_main_schedd()

    ###################################
    # configure the GCB routing tables
    gcb_list=get_gcb_list()

    if len(gcb_list)>0: # do not need to configure if not using GCBs at all
        config_fd=open("%s/etc/gcb-routing-table"%CONDOR_BASE_PATH,"w")
        try:
            for gcb_entry in gcb_list:
                config_fd.write("%s/32 GCB\n"%gcb_entry)
        finally:
            config_fd.close()

        config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
        try:
            config_fd.write("#####################################\n")
            config_fd.write("# Tell schedd daemons where is GCB\n")
            config_fd.write("#####################################\n")
            config_fd.write("SCHEDD.NET_REMAP_ENABLE=TRUE\n")
            config_fd.write("SCHEDD.NET_REMAP_SERVICE=GCB\n")
            config_fd.write("SCHEDD.NET_REMAP_ROUTE=%s/etc/gcb-routing-table\n\n"%CONDOR_BASE_PATH)
        finally:
            config_fd.close()

    ##################################
    # configure secondary schedds
    if not SECONDARY_SCHEDD_SUPPORT_FILES_INSTALLED:
        create_secondary_schedd_support_files()
    
    while 1:
        nr_schedds_default=9
        nr_schedds_str=raw_input("How many secondary schedds do you want?: [9] ")
        if nr_schedds_str=="":
            nr_schedds_str="%s"%nr_schedds_default
        try:
            nr_schedds=int(nr_schedds_str)
        except:
            print "'%s' is not a number!"%nr_schedds_str
            continue
        if nr_schedds<0:
            print "You entered a negative number! (%i)"%nr_schedds
            continue
        if nr_schedds>99: # security check
            print "You entered too big of a number! (%i)"%nr_schedds
            continue

        break # have the number of schedds

    for i in range(nr_schedds):
        schedd_name="jobs%i"%(i+1)
        configure_secondary_schedd(schedd_name)

    restart_condor()

    print "**************************************************"
    print "User submit schedd installation succeeded"
    print "**************************************************"
    print
        
    return

#-------------------------------------------------------------------------------
def wms_install():
    global VDT_BASE_PATH
    global CONDOR_BASE_PATH
    global GSI_SECURITY_CONFIGURED
    global QUILL_CONFIG_DONE
    global SECONDARY_SCHEDD_SUPPORT_FILES_INSTALLED
    global COLLECTOR_INSTALLED
    global CONDOR_UPD_CONFIG_FILE

    print "Installing WMS collector"
    print

    if VDT_BASE_PATH==None:
        query_vdt()

    condor_was_installed=(CONDOR_BASE_PATH!=None)
    if CONDOR_BASE_PATH==None:
        install_condor()

    if not GSI_SECURITY_CONFIGURED:
        configure_gsi_security()

    if not QUILL_CONFIG_DONE:
        yn=raw_input("Do you want to Use Quill (works for 6.8.X only)?: (y/n) [n]")
        if yn=='y':
            setup_quill()

    if not COLLECTOR_INSTALLED:
        setup_collector('My glideinWMS pool')
    
    if not MAIN_SCHEDD_INSTALLED:
        setup_main_schedd()

    ################################
    # Set optimized Condor-G values
    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("\n######################################################\n")
        config_fd.write("## Condor-G tuning\n")
        config_fd.write("######################################################\n\n")
        config_fd.write("GRIDMANAGER_LOG = /tmp/GridmanagerLog.$(SCHEDD_NAME).$(USERNAME)\n")
        config_fd.write("GRIDMANAGER_MAX_SUBMITTED_JOBS_PER_RESOURCE=5000\n")
        config_fd.write("GRIDMANAGER_MAX_PENDING_SUBMITS_PER_RESOURCE=5000\n")
        config_fd.write("GRIDMANAGER_MAX_PENDING_REQUESTS=500\n")
    finally:
        config_fd.close()

    ##################################
    # configure secondary schedds
    if not SECONDARY_SCHEDD_SUPPORT_FILES_INSTALLED:
        create_secondary_schedd_support_files()
    
    while 1:
        nr_schedds_default=9
        nr_schedds_str=raw_input("How many secondary schedds do you want?: [9] ")
        if nr_schedds_str=="":
            nr_schedds_str="%s"%nr_schedds_default
        try:
            nr_schedds=int(nr_schedds_str)
        except:
            print "'%s' is not a number!"%nr_schedds_str
            continue
        if nr_schedds<0:
            print "You entered a negative number! (%i)"%nr_schedds
            continue
        if nr_schedds>99: # security check
            print "You entered too big of a number! (%i)"%nr_schedds
            continue

        break # have the number of schedds

    for i in range(nr_schedds):
        schedd_name="glideins%i"%(i+1)
        configure_secondary_schedd(schedd_name)

    restart_condor()

    print "******************************************"
    print "WMS collector successfully installed"
    print "******************************************"
    print

    return

#-------------------------------------------------------------------------------
def condor_frontend_install():
    global CONDOR_BASE_PATH
    global VDT_BASE_PATH
    global CONDOR_UPD_CONFIG_FILE

    if (CONDOR_BASE_PATH==None) or (VDT_BASE_PATH==None):
        if os.getuid()==0:
            print
            print "You are trying to install Condor for the VO Frontend as root"
            print "While this is possible, it is not recommended."
            print "For security reasons, it is better to install it as a non-priviledged user"
            yn=raw_input("Do you want to continue?: (y/n) ")
            if yn!='y':
                print
                print "Not installing Condor for VO Frontend as root."
                print "Remember to install it as a regular user"
                print
                return

    print
    print "Installing Condor for VO Frontend"
    print

    if VDT_BASE_PATH==None:
        query_vdt()

    if CONDOR_BASE_PATH==None:
        install_condor()

        setup_main_schedd()
        
        ####################################################
        # If used only for the VO frontend, disable daemons
        config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
        try:
            config_fd.write("\n######################################################\n")
            config_fd.write("## The client needs GSI authentication\n")
            config_fd.write("######################################################\n")
            config_fd.write("SEC_DEFAULT_AUTHENTICATION_METHODS = FS,GSI\n\n")
            config_fd.write("######################################################\n")
            config_fd.write("## This machine should run no daemons\n")
            config_fd.write("######################################################\n")
            config_fd.write("DAEMON_LIST=MASTER\n")
            config_fd.write("DAEMON_SHUTDOWN=True\n\n")
        finally:
            config_fd.close()
    # else nothing to be done

    #
    # No need to start condor, client only
    #

    print
    print "Condor for VO Frontend installed"
    print
    return

#-------------------------------------------------------------------------------
def gcb_install():
    global CONDOR_BASE_PATH
    global COLLECTOR_INSTALLED
    global MAIN_SCHEDD_INSTALLED
    global QUILL_CONFIG_DONE
    global CONDOR_UPD_CONFIG_FILE
    
    if os.getuid()==0:
        print
        print "You are trying to install GCB as root"
        print "While this is possible, it is not recommended."
        print "For security reasons, it is better to install it as a non-priviledged user"
        yn=raw_input("Do you want to continue?: (y/n) ")
        if yn!='y':
            print
            print "Not installing GCB as root."
            print "Remember to install it as a regular user"
            print
            return
    print
    print "Installing GCB"
    print
    if CONDOR_BASE_PATH==None:
        install_condor()

    ################################
    # Configure GCB
    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("\n######################################################\n")
        config_fd.write("## GCB configuration\n")
        config_fd.write("######################################################\n\n")
        config_fd.write("# Define the path to the broker binary for the master to spawn\n")
        config_fd.write("GCB_BROKER = $(RELEASE_DIR)/libexec/gcb_broker\n\n")

        config_fd.write("# Define the path to the release_server binary for the broker to use\n")
        config_fd.write("GCB_RELAY = $(RELEASE_DIR)/libexec/gcb_relay_server\n\n")

        config_fd.write("# Setup the gcb_broker's environment.  We use a macro to build up the\n")
        config_fd.write("# environment we want in pieces, and then finally define\n")
        config_fd.write("# GCB_BROKER_ENVIRONMENT, the setting that condor_master uses.\n\n")

        config_fd.write("# Initialize an empty macro\n")
        config_fd.write("GCB_BROKER_ENV =\n\n")

        config_fd.write("# (recommended) Provide the full path to the gcb_relay_server\n")
        config_fd.write("GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_RELAY_SERVER=$(GCB_RELAY)\n\n")

        config_fd.write("# (recommended) Tell GCB to write all log files into the Condor log\n")
        config_fd.write("# directory (the directory used by the condor_master itself)\n")
        config_fd.write("GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_LOG_DIR=$(LOG)\n")
        config_fd.write("# Or, you can specify a log file seperately for each GCB daemon:\n")
        config_fd.write("GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_BROKER_LOG=$(LOG)/GCB_Broker_Log;GCB_RELAY_SERVER_LOG=$(LOG)/GCB_RS_Log\n\n")

        config_fd.write("# (optional -- only set if true) Tell the GCB broker that it can\n")
        config_fd.write("# directly connect to machines in the private network which it is\n")
        config_fd.write("# handling communication for.  This should only be enabled if the GCB\n")
        config_fd.write("# broker is running directly on a network boundry and can open direct\n")
        config_fd.write("# connections to the private nodes.\n")
        config_fd.write("#GCB_BROKER_ENV = $(GCB_BROKER_ENV);ACTIVE_TO_CLIENT=yes\n\n")

        config_fd.write("# (optional) turn on verbose logging for all of GCB\n")
        config_fd.write("#GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_DEBUG_LEVEL=fulldebug\n")
        config_fd.write("# Or, you can turn this on seperately for each GCB daemon:\n")
        config_fd.write("#GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_BROKER_DEBUG=fulldebug\n")
        config_fd.write("#GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_RELAY_SERVER_DEBUG=fulldebug\n\n")

        config_fd.write("# (optional) specify the maximum log file size (in bytes)\n")
        config_fd.write("GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_MAX_LOG=6400000\n")
        config_fd.write("# Or, you can define this seperately for each GCB daemon:\n")
        config_fd.write("#GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_BROKER_MAX_LOG=64000000\n")
        config_fd.write("#GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_RELAY_SERVER_MAX_LOG=640000\n\n")

        config_fd.write("# How many connections should it serve\n")
        config_fd.write("# By multiplying the two you get the number of used ports\n")
        config_fd.write("# If you increase it, make sure your machine supports enough port\n")
        config_fd.write("#   see /proc/sys/net/ipv4/ip_local_port_range\n")
        config_fd.write("GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_MAX_RELAY_SERVERS=200\n")
        config_fd.write("GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_MAX_CLIENTS_PER_RELAY_SERVER=100\n\n")

        config_fd.write("# How tolerant should it be to blocked connections\n")
        config_fd.write("GCB_BROKER_ENV = $(GCB_BROKER_ENV);GCB_COMMAND_TIMEOUT=1.5\n\n")

        config_fd.write("# Finally, set the value the condor_master really uses\n")
        config_fd.write("GCB_BROKER_ENVIRONMENT = $(GCB_BROKER_ENV)\n\n")

        config_fd.write("# If your Condor installation on this host already has a public\n")
        config_fd.write("# interface as the default (either because it is the first interface\n")
        config_fd.write("# listed in this machine's host entry, or because you've already\n")
        config_fd.write("# defined NETWORK_INTERFACE), you can just use Condor's special macro\n")
        config_fd.write("# that holds the IP address for this.\n")
        config_fd.write("GCB_BROKER_IP = $(ip_address)\n")
        config_fd.write("# Otherwise, you could define it yourself with your real public IP:\n")
        config_fd.write("#GCB_BROKER_IP = 131.225.70.222\n\n")

        config_fd.write("# (required) define the command-line arguments for the broker\n")
        config_fd.write("GCB_BROKER_ARGS = -i $(GCB_BROKER_IP)\n")
    finally:
        config_fd.close()

    
    ################################
    # Enable the GCB daemon
    daemon_list="MASTER"

    if COLLECTOR_INSTALLED:
        daemon_list=daemon_list+", COLLECTOR, NEGOTIATOR" 
    if MAIN_SCHEDD_INSTALLED:
        daemon_list=daemon_list+", SCHEDD" 
        if QUILL_CONFIG_DONE:
            daemon_list=daemon_list+", QUILL" 

    if (not COLLECTOR_INSTALLED) and (not MAIN_SCHEDD_INSTALLED):
        # this is a fresh install, I need a private collector
        daemon_list=daemon_list+", COLLECTOR"

    ################################
    # Configure GCB
    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("\n######################################################\n")
        config_fd.write("## Add GCB to the list of daemons\n")
        config_fd.write("######################################################\n\n")
        config_fd.write("DAEMON_LIST = %s, GCB_BROKER\n\n"%daemon_list)
    finally:
        config_fd.close()

    restart_condor()

    print
    print "GCB installed"
    print
    return

#-------------------------------------------------------------------------------
def gfactory_install():
    global VDT_BASE_PATH
    global HTTPD_PORT
    
    if os.getuid()==0:
        print
        print "You are trying to install the Glidein Factory as root"
        print "While this is possible, it is not recommended."
        print "For security reasons, it is better to install it as a non-priviledged user"
        yn=raw_input("Do you want to continue?: (y/n) ")
        if yn!='y':
            print
            print "Not installing the Glidein Factory as root."
            print "Remember to install it as a regular user"
            print
            return

    print
    print "Installing Glidein Factory"
    print


    glideinWMS_base_dir=os.path.dirname(os.path.dirname(os.path.abspath(sys.argv[0])))
    if not os.path.isdir("%s/creation"%glideinWMS_base_dir):
        raise RuntimeError,"Cannot find %s/creation"%glideinWMS_base_dir

    check_import('rrdtool')
    check_import('M2Crypto')
    
    if VDT_BASE_PATH==None:
        if os.environ.has_key('OSG_VDT_BASE'):
            VDT_BASE_PATH=os.environ['OSG_VDT_BASE']

    if VDT_BASE_PATH==None:
        query_vdt()


    ###################################
    # Ask about the proxy
    print "To use the Glidein Factory you need a valid GSI proxy."
    while 1:
        if os.environ.has_key('X509_USER_PROXY'):
            proxy_fname=raw_input("Where is your proxy located?: [%s] "%os.environ['X509_USER_PROXY'])
            if proxy_fname=="":
                proxy_fname=os.environ['X509_USER_PROXY']
        else:
            proxy_fname=raw_input("Where is your proxy located?: ")
        proxy_fname=os.path.abspath(proxy_fname)

        try:
            my_dn=get_proxy_dn(proxy_fname)
        except RuntimeError,e:
            print e
            continue
            
        break # proxy found

    print
    print "Using DN '%s'"%my_dn
    print "Make sure this DN is in the condor_mapfiles of the WMS and pool collectors"
    print "  as well as all the Condor schedds."
    print

    #################################
    # get config vals
    full_host_name=socket.getfqdn()
    fhn_arr=full_host_name.split(".")

    # Submit base directory
    def_submit_base_dir="%s/glideinsubmit"%os.environ['HOME']
    while 1:
        submit_base_dir=raw_input("Where will you host your config and log files?: [%s]"%def_submit_base_dir)
        if submit_base_dir=="":
            submit_base_dir=def_submit_base_dir
        if not os.path.isdir(submit_base_dir):
            print "'%s' is not a directory!"%submit_base_dir
            continue
        # found it
        break

    
    while 1:
        default_web_base_dir='/var/www/html/glidefactory'
        web_base_dir=create_empty_dir("Where will the web data be hosted?: ",default_web_base_dir,empty_required=False)

        # create stage and monitor subdirs, if needed
        for sdir_name in ("stage","monitor"):
            sdir_fullpath=os.path.join(web_base_dir,sdir_name)
            if not os.path.exists(sdir_fullpath):
                try:
                    os.mkdir(sdir_fullpath)
                except:
                    print "Cannot create dir '%s'"%sdir_fullpath
                    continue

                test_fname=os.path.join(sdir_fullpath,"test.txt")
                try:
                    fd=open(test_fname,"w")
                    fd.close()
                    os.unlink(test_fname)
                except:
                    print "Dir '%s' not writable."%sdir_fullpath
                    continue
        break # everything worked, go on 
        

    # Web URL
    if HTTPD_PORT==None:
        default_web_base_url="http://%s/glidefactory/"%full_host_name
    else:
        default_web_base_url="http://%s:%s/glidefactory/"%(full_host_name,HTTPD_PORT)

    while 1:
        web_base_url=raw_input("What Web URL will you use?: [%s] "%default_web_base_url)
        if web_base_url=="":
            web_base_url=default_web_base_url

        if web_base_url[-1]!='/':
            web_base_url+='/'

        if web_base_url[:7]=="http://":
            web_url_type="http"
            web_base_url_noproto=web_base_url[7:]
        elif web_base_url[:8]=="https://":
            yn=raw_input("HTTPS is quite expensive and cannot be cached?\nAre you sure you want to use it? : (y/n) ")
            if yn!="y":
                continue
            web_url_type="https"
            web_base_url_noproto=web_base_url[8:]
        elif web_base_url[:6]=="ftp://":
            yn=raw_input("FTP will usually not be cached?\nAre you sure you want to use it? : (y/n) ")
            if yn!="y":
                continue
            web_url_type="ftp"
            web_base_url_noproto=web_base_url[6:]
        else:
            tmp=web_base_url.split(':',1)
            print "Unknown protocol %s (http, https and ftp supported)!"%tmp
            continue

        web_base_url_noproto_arr=web_base_url_noproto.split('/',1)
        if len(web_base_url_noproto_arr)!=2:
            print "Invalid URL: %s"%web_base_url
            continue

        web_base_url_host=web_base_url_noproto_arr[0]
        web_base_url_path=web_base_url_noproto_arr[1]

        if web_url_type=="ftp":
            try:
                fc=ftplist.FTP(web_base_url_host)
                rc=fc.login()
                rc=fc.cwd(web_base_url_path+"stage/")
                fc.close()
            except:
                print "Failed connecting to: %s"%web_base_url
                continue
        else:
            web_base_url_host_arr=web_base_url_host.split(':',1)
            web_base_url_host_name=web_base_url_host_arr[0]
            if len(web_base_url_host_arr)>1:
                try:
                    web_base_url_host_port=int(web_base_url_host_arr[1])
                except:
                    print "Invalid port number in URL: %s"%web_base_url
                    continue
            else:
                web_base_url_host_port=None

            try:
                if web_url_type=='http':
                    hc=httplib.HTTPConnection(web_base_url_host_name,web_base_url_host_port)
                else:
                    hc=httplib.HTTPSConnection(web_base_url_host_name,web_base_url_host_port)
                hc.connect()
                hc.request("GET", "/%sstage/"%web_base_url_path)
                rc = hc.getresponse()
                hc.close()
                if rc.status!=200:
                    raise RuntimError,"http failed %i"%rc.status
            except:
                print "Failed connecting to: %s"%web_base_url
                continue

        # found and verified the installation
        break

    #if RRD_BIN_PATH==None:
    #    query_rrd()

    # Factory name
    def_factory_name=fhn_arr[0]
    factory_name=raw_input("Give a name to this Glidein Factory?: [%s] "%def_factory_name)
    if factory_name=="":
        factory_name=def_factory_name

    # Glidein name
    def_glidein_name="v1_0"
    while 1:
        glidein_name=raw_input("Give a name to this Glidein instance?: [%s] "%def_glidein_name)
        if glidein_name=="":
            glidein_name=def_glidein_name
        # check if dir already exists
        if os.path.exists('%s/glidein_%s'%(submit_base_dir,glidein_name)):
            print "Glidein '%s' already exists!"%glidein_name
            continue
        if os.path.exists('%s/glidein_%s.cfg'%(submit_base_dir,glidein_name)):
            print "Glidein config area for '%s' already exists!"%glidein_name
            continue

        #have it
        break

    # Condor base dir
    fd=os.popen("which condor_status")
    lines=fd.readlines()
    err=fd.close()
    if err!=None: # found
        raise RuntimeError, "Failed to detect condor installation!"
    def_condor_base_dir=os.path.dirname(os.path.dirname(lines[0][:-1])) 
    while 1:
        condor_base_dir=raw_input("What is the Condor base directory?: [%s] "%def_condor_base_dir)
        if condor_base_dir=="":
            condor_base_dir=def_condor_base_dir
        condor_startd_bin=os.path.join(condor_base_dir,'sbin/condor_startd')
        if not os.path.exists(condor_startd_bin):
            print "%s does not exist!"%condor_startd_bin
            continue
        # found and verified
        break

    # schedds
    fd=os.popen("condor_status -schedd -format '%s\n' Name")
    lines=fd.readlines()
    err=fd.close()
    if err!=None: # found
        raise RuntimeError, "Failed to fetch list of schedds!"

    default_schedds=[]
    for line in lines:
        line=line[:-1] #remove newline
        if line[:14]=="schedd_glidein":
            default_schedds.append(line)

    if len(default_schedds)==0:
        while 1:
            yn=raw_input("No glidein schedds in this pool.\nDo you want to use the other schedds? (y/n) ")
            if (yn!="y") and (yn!="n"):
                print "Please answer y or n"
                continue 
            break
        if yn=='y':
            default_schedds=[]
            for line in lines:
                line=line[:-1] #remove newline
                if len(line)>0:
                    default_schedds.append(line)
        else:
            raise RuntimeError, "No glidein schedds in this pool!"


    print "The following glidein schedds have been found:"
    for i in range(len(default_schedds)):
        print " [%i] %s"%(i+1,default_schedds[i])
    
    while 1:
        yn=raw_input("Do you want to use all of them?: (y/n) ")
        if (yn!="y") and (yn!="n"):
            print "Please answer y or n"
            continue 
        break

    if yn=="y":
        schedds=default_schedds
    else:
        print "Select the schedd indexes you want to use"
        print "Use a , separated list to use more than one"
        while 1:
            idxes=raw_input("Please select: ")
            idx_arr=idxes.split(',')
            problems=0
            for i in range(len(idx_arr)):
                try:
                    nr=int(idx_arr[i])
                    if (nr<1) or (nr>len(default_schedds)):
                        print "Index %i out of range"%nr
                        problems=1
                        break
                    idx_arr[i]=nr
                except:
                    print "'%s' is not an index!"%idx_arr[i]
            if problems:
                continue

            schedds=[]
            for idx in idx_arr:
                schedds.append(default_schedds[idx-1])
            
            # got them
            break
    print "Using %s"%schedds
    print

    # GCBs
    gcb_list=get_gcb_list()

    #################################
    # create grid-mapfile
    # ask user for additional DNs
    print "My DN = '%s'"%my_dn
    print

    dns={"condor":my_dn}
    print "You will most probably need other DNs in the grid mapfile"
    print "Please add all the DNs that this glidein will connect to"
    print "(usually the Pool Collector and the Submit nodes)"
    print
    print "Please insert all such DNs, together with a user nickname."
    print "An empty DN entry means you are done."
    while 1:
        a_dn=raw_input("DN: ")
        if a_dn=="":
            break # done
        default_uid="condor%03i"%len(dns.keys())
        a_uid=raw_input("nickname: [%s] "%default_uid)
        if a_uid=="":
            a_uid=default_uid
        if a_uid.find(" ")>=0:
            print "WARNING: Nickname cannot contain spaces ('%s'), please reinsert the DN with a different nickname."%a_uid
            continue
        if a_uid in dns.keys():
            print "WARNING: Cannot reuse '%s', please reinsert the DN with a different nickname."%a_uid
            continue
        dns[a_uid]=a_dn


    # Use gLExec
    while 1:
        glexec_yn=raw_input("Do you want to use gLExec?: (y/n) ")
        if (glexec_yn!="y") and (glexec_yn!="n"):
            print "Please answer y or n"
            continue 
        break
    
    # entries
    entries_list={}

    yn=raw_input("Do you want to fetch entries from RESS?: (y/n) [n] ")
    if yn=='y':
        try:
            vo=get_proxy_vo(proxy_fname)
        except RuntimeError:
            vo=None # VOMS extensions are not required
            
        get_ress_glidein_entries(vo,entries_list,glexec_yn=="y")

    yn=raw_input("Do you want to fetch entries from BDII?: (y/n) [n] ")
    if yn=='y':
        try:
            vo=get_proxy_vo(proxy_fname)
        except RuntimeError:
            vo=None # VOMS extensions are not required
            
        get_bdii_glidein_entries(vo,entries_list,glexec_yn=="y")

    print "Please list all additional glidein entry points,"
    while 1:
        entry_name=raw_input("Entry name (leave empty when finished): ")
        if entry_name=="":
            if len(entries_list.keys())<1:
                print "You must instert at least one entry point"
                continue
            break

        if entry_name in entries_list.keys():
            print "You already insterted '%s'!"%entry_name
            continue
        gatekeeper_name=raw_input("Gatekeeper for '%s': "%entry_name)
        rsl_name=raw_input("RSL for '%s': "%entry_name)
        work_dir=raw_input("Work dir for '%s': "%entry_name)
        site_name=raw_input("Site name for '%s': [%s] "%(entry_name,entry_name))
        if site_name=="":
            site_name=entry_name
        glexec_path=""
        if glexec_yn=="y":
            glexec_path=raw_input("gLExec path for '%s': [OSG] "%entry_name)
            if glexec_path=="":
                glexec_path='OSG'
        else:
            glexec_path="NONE"
            
            
        entries_list[entry_name]={'gatekeeper':gatekeeper_name,'rsl':rsl_name,'gridtype':'gt2',
                                  'work_dir':work_dir,'site_name':site_name,'glexec_path':glexec_path,'is_ids':[]}
        

    # Expose Grid Env
    while 1:
        gridenv_yn=raw_input("Do you want to expose the Grid env. to the user jobs?: (y/n) ")
        if (gridenv_yn!="y") and (gridenv_yn!="n"):
            print "Please answer y or n"
            continue 
        break
    

    os.mkdir('%s/glidein_%s.cfg'%(submit_base_dir,glidein_name))
    
    #####################################
    # create grid mapfile
    grid_mapfile='%s/glidein_%s.cfg/grid-mapfile'%(submit_base_dir,glidein_name)
    gridmap_fd=open(grid_mapfile,"w")
    try:
        for a_uid in dns.keys():
            gridmap_fd.write('"%s" %s\n'%(dns[a_uid],a_uid))
    finally:
        gridmap_fd.close()

    #####################################
    # create config files
    cfg_name='%s/glidein_%s.cfg/glideinWMS.xml'%(submit_base_dir,glidein_name)
    fd=open(cfg_name,"w")
    try:
        try:
            fd.write('<glidein factory_name="%s" glidein_name="%s"\n'%(factory_name,glidein_name))
            fd.write('         schedd_name="%s"\n'%string.join(schedds,','))
            fd.write('         loop_delay="60" advertise_delay="5">\n')
            fd.write('   <submit base_dir="%s"/>\n'%submit_base_dir)
            fd.write('   <stage web_base_url="%s/stage" use_symlink="True" base_dir="%s/stage"/>\n'%(web_base_url,web_base_dir))
            fd.write('   <monitor base_dir="%s/monitor"/>\n'%web_base_dir)
            fd.write('   <condor base_dir="%s"/>\n'%condor_base_dir)
            fd.write('   <attrs>\n')
            fd.write('      <attr name="GLIDEIN_Expose_Grid_Env" value="%s" const="True" parameter="True" glidein_publish="True" publish="True" job_publish="True" type="string"/>\n'%(gridenv_yn=='y'))
            if len(gcb_list)>0:
                fd.write('      <attr name="GCB_LIST" value="%s" const="True" type="string" glidein_publish="False" publish="False" job_publish="False" parameter="True"/>\n'%string.join(gcb_list,','))
            fd.write('   </attrs>\n')
            fd.write('   <entries>\n')
            sorted_entry_names=entries_list.keys()
            sorted_entry_names.sort()
            for entry_name in sorted_entry_names:
                entry_el=entries_list[entry_name]
                if entry_el['rsl']!="":
                    rsl_str='rsl=%s'%xml.sax.saxutils.quoteattr(entry_el['rsl'])
                else:
                    rsl_str=""
                
                fd.write('      <entry name="%s" gridtype="%s" gatekeeper="%s" %s work_dir="%s">\n'%(entry_name,entry_el['gridtype'],entry_el['gatekeeper'],rsl_str,entry_el['work_dir']))
                fd.write('         <infosys_refs>\n')
                for is_el in entry_el['is_ids']:
                    fd.write('           <infosys_ref type="%s" server="%s" ref="%s"/>\n'%(is_el['type'],is_el['server'],is_el['name']))
                fd.write('         </infosys_refs>\n')
                fd.write('         <attrs>\n')
                fd.write('            <attr name="GLIDEIN_Site" value="%s" const="True" type="string" glidein_publish="True" publish="True" job_publish="True" parameter="True"/>\n'%entry_el['site_name'])
                # Put GCB_ORDER in the entries so that it is easy to disable it selectively
                if len(gcb_list)>0:
                    fd.write('            <attr name="GCB_ORDER" value="RANDOM" const="False" type="string" glidein_publish="False" publish="True" job_publish="False" parameter="True"/>\n')
                else:
                    fd.write('            <attr name="GCB_ORDER" value="NONE" const="True" type="string" glidein_publish="False" publish="False" job_publish="False" parameter="True"/>\n')
                fd.write('            <attr name="GLEXEC_BIN" value="%s" const="True" type="string" glidein_publish="False" publish="False" job_publish="False" parameter="True"/>\n'%entry_el['glexec_path'])
                fd.write('         </attrs>\n')
                fd.write('         <files>\n')
                fd.write('         </files>\n')
                fd.write('      </entry>\n')
            fd.write('   </entries>\n')
            fd.write('   <files>\n')
            fd.write('      <file executable="False" absfname="%s" untar="False" const="True" relfname="grid-mapfile"/>\n'%grid_mapfile)
            fd.write('   </files>\n')
            fd.write('</glidein>\n')
        finally:
            fd.close()
    except:
        try:
            os.unlink(cfg_name)
        except:
            pass #just protect
        raise
        
    #####################################
    # run create_glidein

    yn=raw_input("Do you want to create the glidein (as opposed to just the config file)?: (y/n) [n]")
    if yn=='y':
        err=os.system('%s/creation/create_glidein %s'%(glideinWMS_base_dir,cfg_name))
        if err!=0:
            print "Failed to create glidein '%s'!"%glidein_name
            print "You may need to change the configuration file first"
    else:
        print "To create the glidein, you need to run"
        print '%s/creation/create_glidein'%glideinWMS_base_dir

    print
    print "Configuration files are located in %s/glidein_%s.cfg"%(submit_base_dir,glidein_name)
    print "Remember to set X509_USER_PROXY before starting the daemon"
    print

    return

#-------------------------------------------------------------------------------
def extract_job_attrs(match_str):
    job_attrs=[]
    attr_re=re.compile("job\[['\"](?P<attr>[^'\"]+)['\"]\]")

    idx=0
    while 1:
        attr_obj=attr_re.search(match_str,idx)
        if attr_obj==None:
            break # not found
        attr_el=(attr_obj.group('attr'),'s') # assume it is string, don't have better info
        if not (attr_el in job_attrs):
            job_attrs.append(attr_el)
        idx=attr_obj.end()+1
    return job_attrs
    

def vofrontend_install():
    global VDT_BASE_PATH
    if os.getuid()==0:
        print
        print "You are trying to install the VO Frontend as root"
        print "While this is possible, it is not recommended."
        print "For security reasons, it is better to install it as a non-priviledged user"
        yn=raw_input("Do you want to continue?: (y/n) ")
        if yn!='y':
            print
            print "Not installing the VO Frontend as root."
            print "Remember to install it as a regular user"
            print
            return

    print
    print "Installing VO Frontend"
    print


    glideinWMS_base_dir=os.path.dirname(os.path.dirname(os.path.abspath(sys.argv[0])))
    if not os.path.isdir("%s/frontend"%glideinWMS_base_dir):
        raise RuntimeError,"Cannot find %s/frontend"%glideinWMS_base_dir

    if VDT_BASE_PATH==None:
        if not os.environ.has_key('OSG_VDT_BASE'):
            raise "Cannot find the OSG VDT client! (OSG_VDT_BASE not defined)"
        else:
            VDT_BASE_PATH=os.environ['OSG_VDT_BASE']

    ###################################
    # Ask about the proxy
    print "To use the VO Frontend you need a valid GSI proxy."
    while 1:
        if os.environ.has_key('X509_USER_PROXY'):
            proxy_fname=raw_input("Where is your proxy located?: [%s] "%os.environ['X509_USER_PROXY'])
            if proxy_fname=="":
                proxy_fname=os.environ['X509_USER_PROXY']
        else:
            proxy_fname=raw_input("Where is your proxy located?: ")
        proxy_fname=os.path.abspath(proxy_fname)

        try:
            my_dn=get_proxy_dn(proxy_fname)
        except RuntimeError,e:
            print e
            continue
            
        break # proxy found

    print
    print "Using DN '%s'"%my_dn
    print "Make sure this DN is in the WMS collector grid-mapfile"
    print


    #################################
    # get config vals
    full_host_name=socket.getfqdn()
    fhn_arr=full_host_name.split(".")

    # VO Frontend name
    def_frontend_name="%s_%s"%(fhn_arr[-2],fhn_arr[0])
    frontend_name=raw_input("Give a name to this VO Frontend?: [%s] "%def_frontend_name)
    if frontend_name=="":
        frontend_name=def_frontend_name

    # WMS collector node
    while 1:
        pool_node=raw_input("What node is the WMS collector running?: ")
        try:
            socket.gethostbyname(pool_node)
        except:
            print "'%s' not a valid host name!"%pool_node
            continue
        #have a valid pool_node
        break

    # collector
    fd=os.popen("condor_config_val COLLECTOR_HOST")
    lines=fd.readlines()
    err=fd.close()
    if err!=None: # found
        default_local_collector=""
    else:
        default_local_collector=lines[0][:-1]

    print
    print "What node is the pool collector running on?"
    print "If you have a hierarchy of collectors, list them all"
    print "(for example: master1.my.org:9620,master1.my.org:9621,master1.my.org:9622,master1.my.org:9623,master1.my.org:9624)"
    while 1:
        local_collector=raw_input("Collector name(s): [%s]"%default_local_collector)
        if local_collector=="":
            local_collector=default_local_collector
        if local_collector!="":
            break
        print "Empty string not a valid collector"

    # schedds
    fd=os.popen("condor_status -schedd -format '%s\n' Name")
    lines=fd.readlines()
    err=fd.close()
    if err!=None: # found
        raise RuntimeError, "Failed to fetch list of schedds!"

    default_schedds=[]
    for line in lines:
        line=line[:-1] #remove newline
        if line!="":
            default_schedds.append(line)

    if len(default_schedds)==0:
        raise RuntimeError, "No schedds in this pool!"

    print "The following schedds have been found:"
    for i in range(len(default_schedds)):
        print " [%i] %s"%(i+1,default_schedds[i])
    
    while 1:
        yn=raw_input("Do you want to monitor all of them?: (y/n) ")
        if (yn!="y") and (yn!="n"):
            print "Please answer y or n"
            continue 
        break

    if yn=="y":
        schedds=default_schedds
    else:
        print "Select the schedd indexes you want to monitor"
        print "Use a , separated list to monitor more than one"
        while 1:
            idxes=raw_input("Please select: ")
            idx_arr=idxes.split(',')
            problems=0
            for i in range(len(idx_arr)):
                try:
                    nr=int(idx_arr[i])
                    if (nr<1) or (nr>len(default_schedds)):
                        print "Index %i out of range"%nr
                        problems=1
                        break
                    idx_arr[i]=nr
                except:
                    print "'%s' is not an index!"%idx_arr[i]
                    problems=1
                    break
                
            if problems:
                continue

            schedds=[]
            for idx in idx_arr:
                schedds.append(default_schedds[idx-1])
            
            # got them
            break
    print "Using %s"%schedds
    print


    # match string
    print "What expression do you want to use to match glideins to jobs?"
    print "It is an arbitrary python boolean expression using the dictionaries"
    print "  glidein and job"
    print "A simple example expression would be:"
    print '  glidein["attrs"]["GLIDEIN_Site"] in job["DESIRED_Sites"].split(",")'
    print "If you want to match all (OK for simple setups),"
    print "  just specify 1 (the default)"
    
    default_match_str="1"
    match_str=raw_input("Match string: [%s] "%default_match_str)
    if match_str=="":
        match_str=default_match_str
                    
    print "What attributres are you using in the job expression?"
    print "You need to specify a list of pairs"
    print "Each pair has the name and type of the attributes."
    print "The possible typoes are s,i,r,b (for string, int, real, bool)"
    print "The example above would had:"
    print '  [("DESIRED_Sites","s")]'
    print "I have computed my best estimate for your match string,"
    print "please verify and correct if needed."
    
    default_job_attributes=repr(extract_job_attrs(match_str))
    job_attributes=raw_input("Job attributes: [%s] "%default_job_attributes)
    if job_attributes=="":
        job_attributes=default_job_attributes

    job_attr_list=eval(job_attributes)

    # job constraint
    default_job_constraint="(JobUniverse==5)&&(GLIDEIN_Is_Monitor =!= TRUE)&&(JOB_Is_Monitor =!= TRUE)"
    for job_attr in job_attr_list:
        default_job_constraint+="&&(%s=!=UNDEFINED)"%job_attr[0]
    job_constraint=raw_input("What kind of jobs do you want to monitor?: [%s] "%default_job_constraint)
    if job_constraint=="":
        job_constraint=default_job_constraint
                    
                    
    #####################################
    # create config files
    config_dir=create_empty_dir("Where will you host your config and log files?: ","%s/frontend_%s"%(os.environ['HOME'],frontend_name))

    os.mkdir("%s/log"%config_dir)
    os.mkdir("%s/etc"%config_dir)

    fd=open("%s/etc/vofrontend.cfg"%config_dir,"w")
    try:
        fd.write("# This is a Glidein Frontend config file\n\n")

        fd.write("# How will it be known advertized as\n")
        fd.write("frontend_name=%r\n\n"%frontend_name)

        fd.write("# Where is the WMS collector\n")
        fd.write("# Set to None if the same as for the jobs\n")
        fd.write("factory_pool=%r\n\n"%pool_node)

        fd.write("# List of schedds containing jobs\n")
        fd.write("schedd_names=%r\n\n"%schedds) # this way I get the correct python formatting

        fd.write("# If not all the factory adds has to be considered,\n")
        fd.write("# specify the appropriate constraint\n")
        fd.write("# for example: 'GLIDEIN_Expose_Grid_Env=?=\"True\"'\n")
        fd.write("factory_constraint=None\n\n")

        fd.write("# If not all the jobs of the schedd has to be considered,\n")
        fd.write("# specify the appropriate constraint\n")
        fd.write("# for example: '(JobUniverse==5)'\n")
        fd.write("job_constraint=%r\n\n"%job_constraint)

        fd.write("# What job attributes should I extract?\n")
        fd.write("# for example: [('DESIRED_Sites', 's')]\n")
        fd.write("job_attributes=%s\n\n"%job_attributes)

        fd.write("# String for matching jobs to glideins\n")
        fd.write('# for example: \'glidein["attrs"]["GLIDEIN_Site"] in job["DESIRED_Sites"].split(",")\'\n');
        fd.write("match_string=%r\n\n"%match_str)

        fd.write("# If you want to send a proxy to the factory, specify it here\n")
        fd.write("# The factory must support encryption for this\n")
        fd.write("# x509_proxy = 'your fname here'\n\n")
        
        fd.write("# How much pressure should I apply to the entry points\n")
        fd.write("max_idle_glideins_per_entry=100\n")
        fd.write("# Add a few more to account for Condor-G errors\n")
        fd.write("reserve_idle_glideins_per_entry=5\n\n")
        
        fd.write("# How many idle VMs should I tollerate, before stopping submitting glideins\n")
        fd.write("max_idle_vms_per_entry=100\n")
        fd.write("# When to start curbing submissions\n")
        fd.write("curb_idle_vms_per_entry=5\n\n")
        
        fd.write("# What is the max number of running jobs I want to get to\n")
        fd.write("max_running_jobs=10000 \n\n")

        fd.write("# Glidein parameters\n")
        fd.write("# At least GLIDEIN_Collector must be defined\n")
        fd.write("glidein_params={'GLIDEIN_Collector':%r}\n\n"%local_collector)

        fd.write("# Where to store log files\n")
        fd.write("# Possibly put it in a dedicated directory\n")
        fd.write("log_dir='%s/log'\n\n"%config_dir)

        fd.write("# Frontend works in polling mode\n")
        fd.write("# How much time should pass between a polling loop?\n")
        fd.write("loop_delay=60\n\n")
    finally:
        fd.close()

    fd=open("%s/frontend_startup"%config_dir,"w")
    try:
        fd.write("#!/bin/bash\n")
        fd.write("# condor   This is the glideinWMS frontend startup script\n")
        fd.write("# chkconfig: 35 90 30\n")
        fd.write("# description: Starts and stops a glideinWMS frontend\n\n")
        
        fd.write("# Emulate function library.\n")
        fd.write("success() {\n")
        fd.write(' echo -en "\\033[60G[\033[32mOK\033[0m]"\n')
        fd.write(" return 0\n}\n\n")

        fd.write("failure() {\n")
        fd.write(' echo -en "\\033[60G[\033[31mFAILED\033[0m]"\n')
        fd.write(" return 1\n}\n\n")
        
        fd.write("frontend_dir='%s'\n"%config_dir)
        fd.write("glideinWMS_dir='%s'\n"%glideinWMS_base_dir)
        fd.write("\n")
        
        fd.write('id_str="%s"\n'%frontend_name)
        fd.write("\n")
        
        fd.write("start() {\n")
        fd.write('        echo -n "Starting glideinWMS VO frontend $id_str: "\n')
        fd.write('        "$glideinWMS_dir/frontend/glideinFrontend.py" "$frontend_dir/etc/vofrontend.cfg" 2>/dev/null 1>&2 </dev/null &\n')
        fd.write('        sleep 1\n')
        fd.write('        "$glideinWMS_dir/frontend/checkFrontend.py" "$frontend_dir/etc/vofrontend.cfg"  2>/dev/null 1>&2 </dev/null && success || failure\n')
        fd.write("        RETVAL=$?\n")
        fd.write("        echo\n")
        fd.write("}\n\n")
        
        fd.write("stop() {\n")
        fd.write('        echo -n "Shutting down glideinWMS VO frontend $id_str: "\n')
        fd.write('        "$glideinWMS_dir/frontend/stopFrontend.py" "$frontend_dir/etc/vofrontend.cfg" 2>/dev/null 1>&2 </dev/null && success || failure\n')
        fd.write("        RETVAL=$?\n")
        fd.write("        echo\n")
        fd.write("}\n\n")
        
        fd.write("restart() {\n")
        fd.write("        stop\n")
        fd.write("        start\n")
        fd.write("}\n\n")

        fd.write("reconfig() {\n")
        fd.write('        restart\n')
        fd.write("}\n\n")

        fd.write("case $1 in\n")
        fd.write("        start)\n")
        fd.write("                start\n")
        fd.write("        ;;\n")
        fd.write("        stop)\n")
        fd.write("                stop\n")
        fd.write("        ;;\n")
        fd.write("        restart)\n")
        fd.write("                restart\n")
        fd.write("        ;;\n")
        fd.write("        status)\n")
        fd.write('               "$glideinWMS_dir/frontend/checkFrontend.py" "$frontend_dir/etc/vofrontend.cfg"\n')
        fd.write("               RETVAL=$?\n")
        fd.write("        ;;\n")
        fd.write("        reconfig)\n")
        fd.write("                reconfig $2\n")
        fd.write("        ;;\n")
        fd.write("        *)\n")
        fd.write('        echo $"Usage: frontend_startup {start|stop|restart|reconfig}"\n')
        fd.write("        exit 1\n")
        fd.write("esac\n\n")

        fd.write("exit $RETVAL\n")
    finally:
        fd.close()
    os.chmod("%s/frontend_startup"%config_dir,
             stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

    print
    print "VO Frontend installed in %s/"%config_dir
    print "Config file in %s/etc/vofrontend.cfg"%config_dir
    print "Remember to set X509_USER_PROXY before starting the daemon"
    print


    return

##########################################
#
# Task specific procedures
#
##########################################

# Ask the user for location of directory
# and create it
########################################

def create_empty_dir(question, def_dir,empty_required=True):
    if def_dir!=None:
        question=question+("[%s] "%def_dir)
    while 1:
        user_dir=raw_input(question)
        if user_dir=="":
            user_dir=def_dir
        user_dir=os.path.abspath(user_dir)
        
        if not os.path.exists(user_dir):
            yn=raw_input("Directory '%s' does not exist, should I create it?: (y/n) "%user_dir)
            if yn!="y":
                continue #do not create, ask for a new one
            else:
                try:
                    os.mkdir(user_dir)
                except:
                    print "Failed to create '%s'!"% user_dir
                    continue
        else:
            if len(os.listdir(user_dir))!=0:
                yn='n'
                if not empty_required:
                    while 1:
                        yn=raw_input("Directory '%s' not empty.\nShould I use it anyhow?: (y/n) "% user_dir)
                        if (yn!="y") and (yn!="n"):
                            print "Please answer y or n"
                            continue 
                        break
                if empty_required or (yn!='y'):
                    print "Directory '%s' not empty!"% user_dir
                    continue

        try: # write a test file
            fd=open("%s/test.tst"%user_dir,"w")
            fd.close()
            os.unlink("%s/test.tst"%user_dir)
        except:
            print "Directory '%s' not writtable!"% user_dir
            continue
        
        return user_dir #obtained and checked the directory
 
# Ask the user if it has an OSG client
# Install one else
########################################
def query_vdt():
    global VDT_BASE_PATH

    while 1:
        yn=raw_input("Do you have already a VDT installation?: (y/n) ")
        if (yn!="y") and (yn!="n"):
            print "Please answer y or n"
            continue 

        if yn=="y":
            user_dir=raw_input("Where is the VDT installed?: ")
            user_dir=os.path.abspath(user_dir)
            if not os.path.isfile("%s/setup.sh"%user_dir):
                print "Directory '%s' not a VDT area (does not contain setup.sh)"%user_dir
                continue
            if not os.path.isfile("%s/globus/bin/grid-proxy-info"%user_dir):
                print "Directory '%s' not a Grid VDT area (does not contain globus/bin/grid-proxy-info)"%user_dir
                continue
            # found and verified the installation
            print "Using VDT installation in %s"%user_dir
            print
            VDT_BASE_PATH=user_dir
            return
        else:
            yn=raw_input("Do you want to install the full OSG VDT client?: (y/n) ")
            if (yn!="y"):
                yn=raw_input("Do you want to install a minimal Grid VDT client?: (y/n) ")
                if (yn!="y"):
                    continue # do not install, ask again 
                else:
                    # install the minimal Grid VDT client
                    try:
                        install_vdt(minimal=True)
                    except RuntimeError,e:
                        print "%s"%e
                        continue # ask again
                    return
            else:
              # install OSG VDT client
              try:
                install_vdt(minimal=False)
              except RuntimeError,e:
                print "%s"%e
                continue # ask again
              return

# add a bunch of lines to crontab
###################################
def cron_append(lines,tmp_dir='/tmp'):
    tmp_fname="%s/tmp_%s_%s.tmp"%(tmp_dir,os.getpid(),time.time())
    try:
        os.system("crontab -l >%s"%tmp_fname)
        fd=open(tmp_fname,'a')
        try:
            fd.writelines(lines)
        finally:
            fd.close()
        os.system("crontab %s"%tmp_fname)
    finally:
        if os.path.isfile(tmp_fname):
            os.unlink(tmp_fname)


# Install OSG client
################################
MINIMAL_VDT_PACKAGES=['PPDG-Cert-Scripts','VOMS-Client','CA-Certificates-Updater']

def install_vdt(minimal):
    global VDT_BASE_PATH
    if os.getuid()==0:
        def_vdt_base_path="/opt/vdt"
    else:
        def_vdt_base_path="%s/vdt"%os.environ['HOME']
    
    user_dir=create_empty_dir("Where do you want the VDT installed?: ",def_vdt_base_path)

    while 1:
        default_pacman_version="pacman-3.26"
        pacman_version=raw_input("What pacman version should I use?: [%s] "%default_pacman_version)
        if pacman_version=="":
            pacman_version=default_pacman_version

        # install pacman
        err=os.system("cd %s&&wget http://physics.bu.edu/pacman/sample_cache/tarballs/%s.tar.gz&&tar --no-same-owner -xzvf %s.tar.gz&&rm -f  %s.tar.gz"%(user_dir,pacman_version,pacman_version,pacman_version))
        if err!=0:
            print "Failed to install pacman!"
            continue
        break

    print

    if minimal:
        default_cache_location="http://vdt.cs.wisc.edu/vdt_1101_cache"
        cache_location=raw_input("What VDT cache should I use?: [%s] "%default_cache_location)
        if cache_location=="":
            cache_location=default_cache_location

        package_list=[]
        for p in MINIMAL_VDT_PACKAGES:
            package_list.append("%s:%s"%(cache_location,p))
    else:
        package_list=['OSG:client']

    # ask user about the appropriate platform
    tested_platforms=('linux-rhel-3','SL-3','linux-rhel-4','SL-4','linux-fedora-4','linux-rhel-5','SL-5')
    print "VDT client installation tends to be very picky about the platforms it installs under"
    print "Most of the time, one needs to pretent to be one of the tested platforms"
    print "The platforms known to work are: %s"%string.join(tested_platforms,',')
    while 1:
        platform=raw_input("Which platform do you want to use (leave empty for autodetect): ")
        if platform=="":
            break # no force 
        if not (platform in tested_platforms):
            yn=raw_input("Platform '%s' is not one of the tested ones. Are you sure you want to use it?: (y/n) "%platform)
            if (yn!="y"):
                continue # not sure, reask
        # user selected a platform
        break

    if platform=="":
        platform_str=""
    else:
        platform_str="-pretend-platform %s"%platform
    print
    print "The VDT installation will start in a moment."
    print "CA certificates are installed as part of this procedure; ignore the VDT warning message."
    if not minimal:
        print "Please do not enable Condor, as we will install it separatelly."
    time.sleep(2)
    print

    # install the VDT client
    for p in package_list:
        err=os.system("cd %s/%s;source setup.sh;cd %s&&pacman -trust-all-caches %s -get %s"%(user_dir,pacman_version,user_dir,platform_str,p))
        if err!=0:
            raise RuntimeError,"Failed to install the VDT client!"

    
    # remove the condor component
    # ignore any error
    if not minimal:
        os.system("cd %s/%s;source setup.sh;cd %s&&pacman -remove Condor >/dev/null"%(user_dir,pacman_version,user_dir))

    # initialize CA CRL config 
    default_crl_url="http://software.grid.iu.edu/pacman/cadist/ca-certs-version"
    crl_url=raw_input("Where should I fetch the CAs from?: [%s] "%default_crl_url)
    if crl_url=="":
        crl_url=default_crl_url

    fd=open("%s/vdt/etc/vdt-update-certs.conf"%user_dir,"a")
    try:
        fd.write("\n#CA URL provided during glideinWMS installation\n")
        fd.write("cacerts_url = %s\n"%crl_url)
    finally:
        fd.close()
        
    err=os.system("cd %s;source setup.sh;source vdt-questions.sh; ./vdt/sbin/vdt-setup-ca-certificates"%user_dir)
    if err!=0:
        raise RuntimeError,"Failed to initalize the CAs!"

    # initialize the VDT client
    if os.getuid()==0:
        # automatic if root
        err=os.system("cd %s;source setup.sh;vdt-control --on"%user_dir)
        if err!=0:
            raise RuntimeError,"Failed to initalize the VDT client!"
    else:
        # else need to do it by hand
        # make VDT create the template
        err=os.system("cd %s;source setup.sh;vdt-register-service --enable --name fetch-crl&&vdt-register-service --enable --name vdt-rotate-logs&&vdt-register-service --enable --name vdt-update-certs"%user_dir)
        if err!=0:
            raise RuntimeError,"Failed to initalize the VDT client!"

        # extract the lines to put in cron
        fd=open("%s/vdt/services/state"%user_dir,'r')
        try:
            lines=fd.readlines()
        finally:
            fd.close()

        cron_lines=[]
        for line in lines:
            els=line.split(None,8)
            if len(els)!=9:
                continue # ignore, not a good line
            if (els[1]!='cron') or (els[2]!='enable'):
                continue # not a cron line
            cron_lines.append(string.join(els[3:]))
            # also run it once by hand
            print "Initializing %s"%els[0]
            os.system(els[8])

        # add them to cron
        print "Adding %i lines to crontab"%len(cron_lines)
        cron_append(cron_lines,tmp_dir=user_dir)
        print
        
    if os.getuid()==0: # different if root or not
        # as root

        # put rrd binaries in system wide path
        fd=open("/etc/profile.d/osg_vdt.sh","w")
        try:
            fd.write("export OSG_VDT_BASE=%s\n"%user_dir)
            fd.write("export X509_CERT_DIR=$OSG_VDT_BASE/globus/TRUSTED_CA\n")
        finally:
            fd.close()
        os.chmod("/etc/profile.d/osg_vdt.sh",
                 stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

        fd=open("/etc/profile.d/osg_vdt.csh","w")
        try:
            fd.write("setenv OSG_VDT_BASE %s\n"%user_dir)
            fd.write("setenv X509_CERT_DIR $OSG_VDT_BASE/globus/TRUSTED_CA\n")
        finally:
            fd.close()
        os.chmod("/etc/profile.d/osg_vdt.csh",
                 stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)
    else:
        # as regular user
        
        # put rrd path in .profile
        fd=open("%s/.profile"%os.environ['HOME'],"a")
        try:
            fd.write("\n# OSG vdt client settings\n")
            fd.write("export OSG_VDT_BASE=%s\n"%user_dir)
            fd.write("export X509_CERT_DIR=$OSG_VDT_BASE/globus/TRUSTED_CA\n")
        finally:
            fd.close()
            
        fd=open("%s/.bashrc"%os.environ['HOME'],"a")
        try:
            fd.write("\n# OSG vdt client settings\n")
            fd.write("export OSG_VDT_BASE=%s\n"%user_dir)
            fd.write("export X509_CERT_DIR=$OSG_VDT_BASE/globus/TRUSTED_CA\n")
        finally:
            fd.close()
            
        # and in .cshrc
        fd=open("%s/.cshrc"%os.environ['HOME'],"a")
        try:
            fd.write("\n# OSG vdt client settings\n")
            fd.write("setenv OSG_VDT_BASE %s\n"%user_dir)
            fd.write("setenv X509_CERT_DIR $OSG_VDT_BASE/globus/TRUSTED_CA\n")
        finally:
            fd.close()

    # everything went well, register
    print
    print "VDT client installed"
    print
    
    VDT_BASE_PATH=user_dir
    return

# Create /etc/init.d/condor
# startup script
################################

def create_condor_initd(fname='/etc/init.d/condor',user_condor_base_dir=None):
    if user_condor_base_dir==None:
        raise RuntimeError,"user_condor_base_dir not defined!"
    
    ##################################################
    # init.d file for authomated startup and shutdown
    fd=open(fname,"w")
    try:
        fd.write("#!/bin/bash\n")
        fd.write("# condor   This is the Condor batch system\n")
        fd.write("# chkconfig: 35 90 30\n")
        fd.write("# description: Starts and stops Condor\n\n")
        
        fd.write("# Source function library.\n")
        fd.write("if [ -f /etc/init.d/functions ] ; then\n")
        fd.write("        . /etc/init.d/functions\n")
        fd.write("elif [ -f /etc/rc.d/init.d/functions ] ; then\n")
        fd.write("        . /etc/rc.d/init.d/functions\n")
        fd.write("else\n")
        fd.write("        exit 0\n")
        fd.write("fi\n\n")
        
        fd.write("start() {\n")
        fd.write('        echo -n "Starting condor: "\n')
        fd.write("        %s/start_condor.sh 2>/dev/null 1>&2 && success || failure\n"%user_condor_base_dir)
        fd.write("        RETVAL=$?\n")
        fd.write("        echo\n")
        fd.write("}\n\n")
        
        fd.write("stop() {\n")
        fd.write('        echo -n "Shutting down condor: "\n')
        fd.write("        killall -q -9 condor_master condor_schedd condor_shadow condor_collector condor_negotiator condor_procd condor_gridmanager gahp_server 2>/dev/null 1>&2\n")
        fd.write("        sleep 1\n")
        fd.write("        # If a master is still alive, we have a problem\n")
        fd.write("        killall condor_master 2>/dev/null 1>&2 && failure || success\n")
        fd.write("        RETVAL=$?\n")
        fd.write("        echo\n")
        fd.write("}\n\n")
        
        fd.write("restart() {\n")
        fd.write("        stop\n")
        fd.write("        start\n")
        fd.write("}\n\n")
        
        fd.write("case $1 in\n")
        fd.write("        start)\n")
        fd.write("                start\n")
        fd.write("        ;;\n")
        fd.write("        stop)\n")
        fd.write("                stop\n")
        fd.write("        ;;\n")
        fd.write("        restart)\n")
        fd.write("                restart\n")
        fd.write("        ;;\n")
        fd.write("        status)\n")
        fd.write("                status %s/sbin/condor_master\n"%user_condor_base_dir)
        fd.write("        ;;\n")
        fd.write("        *)\n")
        fd.write('        echo $"Usage: $prog {start|stop|restart|status}"\n')
        fd.write("        exit 1\n")
        fd.write("esac\n\n")
        
        fd.write("exit $RETVAL\n")
    finally:
        fd.close()
    os.chmod(fname,
             stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

# Install Condor from tarball
# and run condor_configure
################################

def install_condor():
    global CONDOR_BASE_PATH
    global CONDOR_USER
    global CONDOR_LOCAL_DIR
    global CONDOR_UPD_CONFIG_FILE

    print "Installing condor"
    print

    ################################
    # Ask which user should run condor
    # and verify it
    if os.getuid()==0:
        # only root can change UID
        def_condor_user="condor"
        while 1:
            condor_user=raw_input("Which user should Condor run under?: [%s] "%def_condor_user)
            if condor_user=="":
                condor_user=def_condor_user
            try:
                pwd.getpwnam(condor_user)
            except:
                print "User '%s' does not exist. Either create it or specify a different user."%condor_user
                continue
            break # got and verified the user
        CONDOR_USER=condor_user
    else:
        CONDOR_USER=pwd.getpwuid(os.getuid())[0]


    ################################
    # Ask for the condor tarball
    # and verify it

    while 1:
        print
        print "You will now need the Condor tarball"
        print "You can find it on http://www.cs.wisc.edu/condor/"
        print "Versions v7.0.5 and 7.1.3 have been tested, but you"
        print "should always use the latest one"
        print
        condor_tarball=raw_input("Where do you have the Condor tarball? ")
        if not os.path.isfile(condor_tarball):
            print "File '%s' not found!"%condor_tarball
            continue

        print "Checking..."

        try:
            fd=tarfile.open(condor_tarball,"r:gz")
        except:
            print "File '%s' not a valid tar.gz file!"%condor_tarball
            continue

        try:
            try:
                first_dir=fd.getnames()[0]
                if (first_dir[:7]!="condor-") or (first_dir[-1]!='/'):
                    print "File '%s' is not a condor tarball! (found '%s', expected 'condor-*/'"%(condor_tarball,first_dir)
                    continue
                condor_version=first_dir[7:-1]
                print "Seems condor version %s"%condor_version
                try:
                    fd.getmember(first_dir+"condor_configure")
                except:
                    print "Filename '%s' missing %s!"%(condor_tarball,first_dir+"condor_configure")
                    continue
                break; # found and verified it
            except:
                print "File '%s' corrupted!"%condor_tarball
                continue
        finally:
            fd.close()
    print

    ################################
    # Ask for the install dir
    # and verify it

    if os.getuid()==0:
        def_condor_base_dir="/opt/glidecondor"
    else:
        def_condor_base_dir="%s/glidecondor"%os.environ['HOME']
    
    user_condor_base_dir=create_empty_dir("Where do you want to install it?: ",def_condor_base_dir)
    tar_dir="%s/tar"%user_condor_base_dir
    os.mkdir(tar_dir)
    print "Installing condor in '%s'"%user_condor_base_dir
    print
    
    ################################
    # Ask for admin email

    while 1:
        admin_email=raw_input("If something goes wrong with Condor, who should get email about it?: ")
        if admin_email.find('@')<0:
            print "'%s' is not a valid email address!"%admin_email
            continue
        break #found and verified

    ################################
    # Do the actual installation
    # Hard fail if anything goes wrong

    try:
        print "Extracting from tarball"
        fd=tarfile.open(condor_tarball,"r:gz")
        # first create the regular files
        for f in fd.getmembers():
            if not f.islnk():
                fd.extract(f,tar_dir)
        # then create the links
        for f in fd.getmembers():
            if f.islnk():
                os.link(os.path.join(tar_dir,f.linkname),os.path.join(tar_dir,f.name))
        fd.close()
    
        print "Running condor_configure"
        CONDOR_LOCAL_DIR="%s/condor_local"%user_condor_base_dir
        install_str="%s/condor-%s/release.tar"%(tar_dir,condor_version)
        if not os.path.isfile(install_str):
            # Condor v7 changed the packaging
            install_str="%s/condor-%s"%(tar_dir,condor_version)

        cmdline="cd %s/condor-%s;./condor_configure --install=%s --install-dir=%s --local-dir=%s --install-log=%s/condor_configure.log"%(tar_dir,condor_version,install_str,user_condor_base_dir,CONDOR_LOCAL_DIR,tar_dir)
        if os.getuid()==0:
            cmdline="%s  --owner=%s"%(cmdline,condor_user)
            
        err=os.system(cmdline)
        if err!=0:
            raise RuntimeError,"condor_configure failed! (%i)"%err
    finally:
        # installation files not needed anymore
        shutil.rmtree(tar_dir)

    yn=raw_input("Do you want to split the config files between condor_config and condor_config.local?: (y/n) [y] ")
    if yn!='n':
      CONDOR_UPD_CONFIG_FILE="%s/etc/condor_config.local"%user_condor_base_dir
      config_fd=open("%s/etc/condor_config"%user_condor_base_dir,"a")
      try:
        config_fd.write("\n########################################################\n")
        config_fd.write("# will use etc/condor_config.local \n")
        config_fd.write("########################################################\n")
        config_fd.write("LOCAL_CONFIG_FILE = %s\n"%CONDOR_UPD_CONFIG_FILE)
      finally:
        config_fd.close()
    else: # else always update the main one
      CONDOR_UPD_CONFIG_FILE="%s/etc/condor_config"%user_condor_base_dir
      config_fd=open("%s/etc/condor_config"%user_condor_base_dir,"a")
      try:
        config_fd.write("\n########################################################\n")
        config_fd.write("# disable additional config files \n")
        config_fd.write("########################################################\n")
        config_fd.write("LOCAL_CONFIG_FILE = \n")
      finally:
        config_fd.close()


    ##################################################
    # Append condor_config.local to main condor_config
    # leave condor_config.local empty

    local_fd=open("%s/condor_local/condor_config.local"%user_condor_base_dir,"r")
    try:
        local_lines=local_fd.readlines()
    finally:
        local_fd.close()

    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("\n########################################################\n")
        config_fd.write("# Whatever condor_configure put into condor_config.local\n")
        config_fd.write("########################################################\n\n")
        config_fd.writelines(local_lines)
    finally:
        config_fd.close()

    # empty official condor_config.local
    local_fd=open("%s/condor_local/condor_config.local"%user_condor_base_dir,"w")
    local_fd.write("\n### Not Used ###\n")
    local_fd.close()

    ##################################################
    # Configure values condor_configure does not
    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("\n######################################################\n")
        config_fd.write("# Base configuration values for glideinWMS\n")
        config_fd.write("######################################################\n\n")
        config_fd.write("##  When something goes wrong with condor at your site, who should get the email?\n")
        config_fd.write("CONDOR_ADMIN = %s\n\n"%admin_email)
        config_fd.write("##  With glideins, there is nothing shared\n")
        config_fd.write("UID_DOMAIN=$(FULL_HOSTNAME)\nFILESYSTEM_DOMAIN=$(FULL_HOSTNAME)\n\n")
        config_fd.write("##  Condor needs to create a few lock files to synchronize access to various log files\n")
        config_fd.write("##  Use the log directory so they are collocated\n")
        config_fd.write("LOCK = $(LOG)\n\n")
        config_fd.write("############################################################\n")
        config_fd.write("## Security config\n")
        config_fd.write("############################################################\n\n")
        config_fd.write("############################\n")
        config_fd.write("# Authentication settings\n")
        config_fd.write("############################\n")
        config_fd.write("SEC_DEFAULT_AUTHENTICATION = REQUIRED\n")
        config_fd.write("SEC_DEFAULT_AUTHENTICATION_METHODS = FS\n")
        config_fd.write("SEC_READ_AUTHENTICATION = OPTIONAL\n")
        config_fd.write("SEC_CLIENT_AUTHENTICATION = OPTIONAL\n\n")
        config_fd.write("############################\n")
        config_fd.write("# Privacy settings\n")
        config_fd.write("############################\n")
        config_fd.write("SEC_DEFAULT_ENCRYPTION = OPTIONAL\n")
        config_fd.write("SEC_DEFAULT_INTEGRITY = REQUIRED\n")
        config_fd.write("SEC_READ_INTEGRITY = OPTIONAL\n")
        config_fd.write("SEC_CLIENT_INTEGRITY = OPTIONAL\n")
        config_fd.write("SEC_READ_ENCRYPTION = OPTIONAL\n")
        config_fd.write("SEC_CLIENT_ENCRYPTION = OPTIONAL\n\n")
        config_fd.write("##  Without strong security, the only secure connection is the local one\n")
        config_fd.write("HOSTALLOW_WRITE = $(FULL_HOSTNAME)\n\n")
    finally:
        config_fd.close()

    ##################################################
    # Put condor in path
    if os.getuid()==0: # different if root or not
        # as root

        #########################################
        # Put link into /etc/condor/condor_config
        if not os.path.exists('/etc/condor'):
            os.mkdir('/etc/condor')
        if os.path.islink('/etc/condor/condor_config') or os.path.exists('/etc/condor/condor_config'):
            # an old version exists... replace
            os.unlink('/etc/condor/condor_config')
        os.symlink("%s/etc/condor_config"%user_condor_base_dir,'/etc/condor/condor_config')

        #########################################
        # put condor binaries in system wide path
        fd=open("/etc/profile.d/condor.sh","w")
        try:
            fd.write("if ! echo ${PATH} | grep -q %s/bin ; then\n"%user_condor_base_dir)
            fd.write("  PATH=${PATH}:%s/bin\n"%user_condor_base_dir)
            fd.write("fi\n")
        finally:
            fd.close()
        os.chmod("/etc/profile.d/condor.sh",
                 stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

        fd=open("/etc/profile.d/condor.csh","w")
        try:
            fd.write("set path = ( $path %s/bin )\n"%user_condor_base_dir)
        finally:
            fd.close()
        os.chmod("/etc/profile.d/condor.csh",
                 stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

    else:
        # as regular user

        #########################################
        # put condor config in .profile
        fd=open("%s/.profile"%os.environ['HOME'],"a")
        try:
            fd.write("\n# Condor settings\n")
            fd.write("if ! echo ${PATH} | grep -q %s/bin ; then\n"%user_condor_base_dir)
            fd.write("  export PATH=%s/bin:${PATH}\n"%user_condor_base_dir)
            fd.write("  export CONDOR_CONFIG=%s/etc/condor_config\n"%user_condor_base_dir)
            fd.write("fi\n\n")
        finally:
            fd.close()
        
        fd=open("%s/.bashrc"%os.environ['HOME'],"a")
        try:
            fd.write("\n# Condor settings\n")
            fd.write("if ! echo ${PATH} | grep -q %s/bin ; then\n"%user_condor_base_dir)
            fd.write("  export PATH=%s/bin:${PATH}\n"%user_condor_base_dir)
            fd.write("  export CONDOR_CONFIG=%s/etc/condor_config\n"%user_condor_base_dir)
            fd.write("fi\n\n")
        finally:
            fd.close()
        
        # and in .cshrc
        fd=open("%s/.cshrc"%os.environ['HOME'],"a")
        try:
            fd.write("\n# Condor settings\n")
            fd.write("set path = ( %s/bin $path)\n"%user_condor_base_dir)
            fd.write("setenv CONDOR_CONFIG %s/etc/condor_config\n\n"%user_condor_base_dir)
        finally:
            fd.close()

        # put condor config in the path for the rest of the installation
        os.environ['CONDOR_CONFIG']="%s/etc/condor_config"%user_condor_base_dir
        if os.environ.has_key('PATH'):
            os.environ['PATH']="%s/bin:%s"%(user_condor_base_dir,os.environ['PATH'])
        else:
            os.environ['PATH']="%s/bin:"%user_condor_base_dir

        print
        print "The Condor config has been put in your login files"
        print "Please remember to exit and reenter the terminal after the install"
        print
        

    ##########################################
    # Put condor binaries in the process path
    if os.environ.has_key('PATH'):
        os.environ['PATH']="%s/bin:%s"%(user_condor_base_dir,os.environ['PATH'])
    else:
        os.environ['PATH']="%s/bin:"%user_condor_base_dir
    
    ##########################################
    # Node wide startup file
    # Will have only primary master for now
    # Any other must be added by someone else
    fd=open("%s/start_condor.sh"%user_condor_base_dir,"w")
    try:
        fd.write("#!/bin/sh\n")
        fd.write("%s/sbin/condor_master\n"%user_condor_base_dir)
        fd.write("sleep 1\n")
    finally:
        fd.close()
    os.chmod("%s/start_condor.sh"%user_condor_base_dir,
             stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

    if os.getuid()==0:
        create_condor_initd('/etc/init.d/condor',user_condor_base_dir)

    ##################################################
    # Condor installed, register it
    CONDOR_BASE_PATH = user_condor_base_dir
    print "Condor installed"
    print
    return

def restart_condor():
    global CONDOR_USER
    global CONDOR_BASE_PATH

    print
    print "Restarting Condor"
    print

    # try to kill old condor daemons, if any
    os.system("pkill -9 -u %s 'condor_.*'"%CONDOR_USER)

    # start condor daemons
    err=os.system("%s/start_condor.sh"%CONDOR_BASE_PATH)
    if err!=0:
        raise RuntimeError, "Failed to start Condor"
    return

# Extact x509 info
################################
def get_proxy_dn(proxy_fname):
    if not os.path.isfile(proxy_fname):
        raise RuntimeError,"Proxy '%s' not found"%proxy_fname

    #extract DN
    dn_fd=os.popen("source %s/setup.sh;grid-proxy-info -file %s"%(VDT_BASE_PATH,proxy_fname))
    dn_blob=dn_fd.read()
    err=dn_fd.close()
    if err!=None:
        raise RuntimeError,"Failed to extract DN from proxy '%s'!"%proxy_fname

    i=dn_blob.find("identity : ")
    if i<0:
        raise RuntimeError,"Failed to extract Identity from proxy '%s'!"%proxy_fname

    dn_blob=dn_blob[i+11:] # remove part before identity
    my_dn=dn_blob[:dn_blob.find('\n')] # keep only the part until the newline
            
    return my_dn

def get_cert_dn(cert_fname):
    if not os.path.isfile(cert_fname):
        raise RuntimeError,"Certificate '%s' not found"%cert_fname

    #extract DN
    dn_fd=os.popen("openssl x509 -subject -in %s"%cert_fname)
    dn_blob=dn_fd.read()
    err=dn_fd.close()
    if err!=None:
        raise RuntimeError,"Failed to extract DN from certificate '%s'!"%cert_fname

    i=dn_blob.find("subject= ")
    if i<0:
        raise RuntimeError,"Failed to extract Subject from certificate '%s'!"%cert_fname

    dn_blob=dn_blob[i+9:] # remove part before subject
    my_dn=dn_blob[:dn_blob.find('\n')] # keep only the part until the newline

    return my_dn

def get_proxy_vo(proxy_fname):
    if not os.path.isfile(proxy_fname):
        raise RuntimeError,"Proxy '%s' not found"%proxy_fname

    #extract VO
    vo_fd=os.popen("source %s/setup.sh;voms-proxy-info -all -file %s"%(VDT_BASE_PATH,proxy_fname))
    vo_blob=vo_fd.read()
    err=vo_fd.close()
    #if err!=None:
    #    raise RuntimeError,"Failed to extract VO from proxy '%s'!"%proxy_fname

    i=vo_blob.find("VO        : ")
    if i<0:
        raise RuntimeError,"Failed to extract VO from proxy '%s'!"%proxy_fname

    vo_blob=vo_blob[i+12:] # remove part before VO
    my_vo=vo_blob[:vo_blob.find('\n')] # keep only the part until the newline
            
    return my_vo

# Update condor config with
# GSI security
################################
def configure_gsi_security():
    global CONDOR_BASE_PATH
    global VDT_BASE_PATH
    global GSI_SECURITY_CONFIGURED
    global CONDOR_UPD_CONFIG_FILE

    print "Configuring GSI security"
    print

    #################################
    # Create security support directory 
    os.mkdir("%s/certs"%CONDOR_BASE_PATH)

    #################################
    # Ask if uses proxy or cert
    # and verify
    print "To use the GSI security, you either need a valid GSI proxy or "
    print "a valid x509 certificate and relative key"
    while 1:
        pc=raw_input("Will you be using a proxy or a cert? (proxy/cert) ")
        if (pc!="proxy") and (pc!="cert"):
            print "Please select either proxy or cert"
            continue

        if pc=="proxy":
            proxy_fname=raw_input("Where is your proxy located?: ")
            proxy_fname=os.path.abspath(proxy_fname)
            
            try:
                my_dn=get_proxy_dn(proxy_fname)
                use_proxy=1
            except RuntimeError,e:
                print e
                continue
            
            break # proxy found
        else:
            cert_fname=raw_input("Where is your certificate located?: ")
            cert_fname=os.path.abspath(cert_fname)
            if not os.path.isfile(cert_fname):
                print "Certificate '%s' not found"%cert_fname
                continue
            cert_keyname=raw_input("Where is your certificate key located?: ")
            cert_keyname=os.path.abspath(cert_keyname)
            if not os.path.isfile(cert_keyname):
                print "Certificate key '%s' not found"%cert_keyname
                continue

            try:
                my_dn=get_cert_dn(cert_fname)
                use_proxy=0
            except RuntimeError,e:
                print e
                continue

            break # cert and key found
            
    print "My DN = '%s'"%my_dn
    print

    #################################
    # create condor_mapfile
    # ask user for additional DNs
    dns={"condor":[my_dn,True]}
    print "You will most probably need other DNs in the condor grid mapfile"
    print "Please add all the DNs that can be used to connect to the "
    print "Condor daemons running on this node"
    print
    print "Please insert all such DNs, together with a user nickname."
    print "An empty DN entry means you are done."
    while 1:
        a_dn=raw_input("DN: ")
        if a_dn=="":
            break # done
        default_uid="condor%03i"%len(dns.keys())
        a_uid=raw_input("nickname: [%s] "%default_uid)
        if a_uid=="":
            a_uid=default_uid
        if a_uid.find(" ")>=0:
            print "WARNING: Nickname cannot contain spaces ('%s'), please reinsert the DN with a different nickname."%a_uid
            continue
        if a_uid in dns.keys():
            print "WARNING: Cannot reuse '%s', please reinsert the DN with a different nickname."%a_uid
            continue
        while 1:
            yn=raw_input("Is this a trusted Condor daemon?: (y/n) ")
            if (yn!="y") and (yn!="n"):
                print "Please answer y or n"
                continue 
            break
        dns[a_uid]=[a_dn,yn=='y']


    # create the condor_mapfile
    condor_mapfile="%s/certs/condor_mapfile"%CONDOR_BASE_PATH
    gridmap_fd=open(condor_mapfile,"w")
    try:
        for a_uid in dns.keys():
            gridmap_fd.write('GSI "%s" %s\n'%(dns[a_uid][0],a_uid))
        gridmap_fd.write('GSI (.*) anonymous\n')
        gridmap_fd.write('FS (.*) \\1\n')
    finally:
        gridmap_fd.close()

    #format the daemon_list
    daemon_dns=[]
    for a_uid in dns.keys():
        a_dn,is_daemon=dns[a_uid]
        if is_daemon:
            daemon_dns.append(a_dn)
    daemon_dns_str=string.join(daemon_dns,',')

    #################################
    # do the config
    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("############################################################\n")
        config_fd.write("## GSI Security config\n")
        config_fd.write("############################################################\n\n")
        config_fd.write("############################\n")
        config_fd.write("# Authentication settings\n")
        config_fd.write("############################\n")
        config_fd.write("SEC_DEFAULT_AUTHENTICATION_METHODS = FS,GSI\n")
        config_fd.write("DENY_WRITE = anonymous@*\n")
        config_fd.write("DENY_ADMINISTRATOR = anonymous@*\n")
        config_fd.write("DENY_DAEMON = anonymous@*\n")
        config_fd.write("DENY_NEGOTIATOR = anonymous@*\n\n")
        config_fd.write("# Grid Certificate directory\n")
        config_fd.write("GSI_DAEMON_TRUSTED_CA_DIR=%s/globus/TRUSTED_CA\n\n"%VDT_BASE_PATH)
        config_fd.write("############################\n")
        config_fd.write("# Set daemon cert location\n")
        config_fd.write("############################\n")
        config_fd.write("GSI_DAEMON_DIRECTORY = %s/certs\n\n"%CONDOR_BASE_PATH)
        config_fd.write("############################\n")
        config_fd.write("# Credentials\n")
        config_fd.write("############################\n")
        if use_proxy:
            config_fd.write("GSI_DAEMON_PROXY = %s\n\n"%proxy_fname)
            config_fd.write("# If you ever decide to use a Certificate, see below\n")
            config_fd.write("#GSI_DAEMON_CERT = /etc/grid-security/hostcert.pem\n")
            config_fd.write("#GSI_DAEMON_KEY  = /etc/grid-security/hostkey.pem\n\n")
        else:
            config_fd.write("GSI_DAEMON_CERT = %s\n"%cert_fname)
            config_fd.write("GSI_DAEMON_KEY  = %s\n\n"%cert_keyname)
            config_fd.write("# If you ever decide to use a Proxy, see below\n")
            config_fd.write("#GSI_DAEMON_PROXY = $(GSI_DAEMON_DIRECTORY)/x509_service_proxy\n\n")

        config_fd.write("#################################\n")
        config_fd.write("# Where to find ID->uid mappings\n")
        config_fd.write("#################################\n")
        config_fd.write("CERTIFICATE_MAPFILE=%s\n\n"%condor_mapfile)

        config_fd.write("#####################################\n")
        config_fd.write("# Add whitelist of condor daemon DNs\n")
        config_fd.write("#####################################\n")
        config_fd.write("GSI_DAEMON_NAME=%s\n\n"%daemon_dns_str)

        config_fd.write("#####################################\n")
        config_fd.write("# Limit session caching to ~12h\n")
        config_fd.write("#####################################\n")
        config_fd.write("SEC_DEFAULT_SESSION_DURATION = 50000\n\n")

        config_fd.write("#####################################################\n")
        config_fd.write("# With strong security, do not use IP based controls\n")
        config_fd.write("#####################################################\n")
        config_fd.write("HOSTALLOW_WRITE = *\n\n")

        config_fd.write("##########################################################\n")
        config_fd.write("# Prepare the Shadow for use with glexec-enabled glideins\n")
        config_fd.write("##########################################################\n")
        config_fd.write("SHADOW.GLEXEC_STARTER = True\n")
        config_fd.write("SHADOW.GLEXEC = /bin/false\n\n")
    finally:
        config_fd.close()


    #################################
    #GSI security configured
    GSI_SECURITY_CONFIGURED=1
    return

# Update condor config with
# collector and negotiator settings
######################################
def setup_collector(default_poolname):
    global CONDOR_BASE_PATH
    global COLLECTOR_INSTALLED
    global CONDOR_UPD_CONFIG_FILE
    
    a_poolname=raw_input("What name would you like to use for this pool?: [%s] "%default_poolname)
    if a_poolname=="":
        a_poolname=default_poolname

    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("\n######################################################\n")
        config_fd.write("## This is a Collector machine, limit deamons\n")
        config_fd.write("######################################################\n")
        config_fd.write("DAEMON_LIST   = MASTER, COLLECTOR, NEGOTIATOR\n")
        config_fd.write("COLLECTOR_NAME = %s\n\n"%a_poolname)
        config_fd.write("############################################################\n")
        config_fd.write("## Negotiator tuning\n")
        config_fd.write("############################################################\n")
        config_fd.write("# Prefer newer claims as they are more likely to be alive\n")
        config_fd.write("NEGOTIATOR_POST_JOB_RANK = MY.LastHeardFrom\n")
        config_fd.write("# Increase negotiation frequency, as new glideins do not trigger a reschedule \n")
        config_fd.write("NEGOTIATOR_INTERVAL = 60\n")
        config_fd.write("NEGOTIATOR_MAX_TIME_PER_SUBMITTER=60\n")
        config_fd.write("NEGOTIATOR_MAX_TIME_PER_PIESPIN=20\n")
        config_fd.write("# Prevent preemption\n")
        config_fd.write("PREEMPTION_REQUIREMENTS = False\n")
        config_fd.write("# negotiator/GCB optimization\n")
        config_fd.write("NEGOTIATOR_INFORM_STARTD = False\n")
    finally:
        config_fd.close()

    COLLECTOR_INSTALLED=1
    return


# Create secondary_collector_support_files
###############################################
def create_secondary_collector_support_files():
    global CONDOR_BASE_PATH
    global CONDOR_LOCAL_DIR
    global SECONDARY_COLLECTOR_SUPPORT_FILES_INSTALLED

    full_host_name=socket.getfqdn()

    ##############################
    # Secondary collector setup file
    fd=open("%s/new_collector_setup.sh"%CONDOR_BASE_PATH,"w")
    try:
        fd.write('if [ $# -ne 1 ]\n')
        fd.write('then\n')
        fd.write(' echo "Collector number expected!"\n')
        fd.write(' return 1\n')
        fd.write('fi\n\n')

        fd.write('COLH=%s\n'%full_host_name)
        fd.write("LD=%s\n"%CONDOR_LOCAL_DIR)

        fd.write('export _CONDOR_COLLECTOR_HOST=$COLH:`expr 9620 + $1`\n')
        fd.write('res=$?\n')
        fd.write('if [ $res -ne 0 ]; then\n')
        fd.write(' echo "Collector number expected, $1 found"\n')
        fd.write(' return 1\n')
        fd.write('fi\n')
        fd.write('export _CONDOR_MASTER_NAME=collector_$1\n')
        fd.write('export _CONDOR_DAEMON_LIST="MASTER, COLLECTOR"\n')
        fd.write('export _CONDOR_LOCAL_DIR=$LD/$_CONDOR_MASTER_NAME\n')
        fd.write('export _CONDOR_LOCK=$_CONDOR_LOCAL_DIR/lock\n')
        fd.write('# Forward all the traffic to the main collector\n')
        fd.write('export _CONDOR_CONDOR_VIEW_HOST=$COLH:9618\n\n')

        fd.write('unset LD\n')
        fd.write('unset COLH\n')
    finally:
        fd.close()
    os.chmod("%s/new_collector_setup.sh"%CONDOR_BASE_PATH,
             stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP)

    #######################################
    # Secondary collector initialization file
    fd=open("%s/init_collector.sh"%CONDOR_BASE_PATH,"w")
    try:
        fd.write("#!/bin/sh\n")
        fd.write("source %s/new_collector_setup.sh $1\n"%CONDOR_BASE_PATH)
        fd.write("# add whatever other config you need\n")
        fd.write("# create needed directories\n")
        fd.write("%s/sbin/condor_init\n"%CONDOR_BASE_PATH)
    finally:
        fd.close()
    os.chmod("%s/init_collector.sh"%CONDOR_BASE_PATH,
             stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

    #######################################
    # Secondary collector startup file
    fd=open("%s/start_master_collector.sh"%CONDOR_BASE_PATH,"w")
    try:
        fd.write("#!/bin/sh\n")
        fd.write("source %s/new_collector_setup.sh $1\n"%CONDOR_BASE_PATH)
        fd.write("# add whatever other config you need\n")
        fd.write("%s/sbin/condor_master\n"%CONDOR_BASE_PATH)
    finally:
        fd.close()
    os.chmod("%s/start_master_collector.sh"%CONDOR_BASE_PATH,
             stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

    SECONDARY_COLLECTOR_SUPPORT_FILES_INSTALLED=1
    return

# Configure the secondary collectors
####################################
def configure_secondary_collector(collector_nr):
    global CONDOR_BASE_PATH

    err=os.system('%s/init_collector.sh %s'%(CONDOR_BASE_PATH,collector_nr))
    if err!=0:
        raise RuntimeError, "Failed to initialize collector '%s'!"%collector_nr

    fd=open("%s/start_condor.sh"%CONDOR_BASE_PATH,"a")
    try:
        fd.write("%s/start_master_collector.sh %s\n"%(CONDOR_BASE_PATH,collector_nr))
    finally:
        fd.close()

# Update condor config with
# schedd settings
################################
def setup_main_schedd():
    global CONDOR_BASE_PATH
    global COLLECTOR_INSTALLED
    global MAIN_SCHEDD_INSTALLED
    global QUILL_CONFIG_DONE
    global CONDOR_UPD_CONFIG_FILE

    # not all the use cases need Quill
    if QUILL_CONFIG_DONE:
        schedd_daemons="SCHEDD, QUILL"
    else:
        schedd_daemons="SCHEDD"

    if not COLLECTOR_INSTALLED:
        # the collector is running on another node, ask which one
        while 1:
            pool_node=raw_input("What node is the collector running (i.e. CONDOR_HOST)?: ")
            try:
                socket.gethostbyname(pool_node)
            except:
                print "'%s' not a valid host name!"%pool_node
                continue
            #have a valid pool_node
            break
        
        config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
        try:
            config_fd.write("\n######################################################\n")
            config_fd.write("## Point to the collector node\n")
            config_fd.write("######################################################\n")
            config_fd.write("CONDOR_HOST = %s\n\n"%pool_node)
            config_fd.write("######################################################\n")
            config_fd.write("## This is a Schedd machine\n")
            config_fd.write("######################################################\n")
            config_fd.write("DAEMON_LIST   = MASTER, %s\n\n"%schedd_daemons)
        finally:
            config_fd.close()
    else:
        config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
        try:
            config_fd.write("######################################################\n")
            config_fd.write("## This is both a Collector and a Schedd machine\n")
            config_fd.write("######################################################\n")
            config_fd.write("DAEMON_LIST   = MASTER, COLLECTOR, NEGOTIATOR, %s\n\n"%schedd_daemons)
        finally:
            config_fd.close()

    ################################
    # Set optimized schedd values
    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("\n######################################################\n")
        config_fd.write("## Schedd tuning\n")
        config_fd.write("######################################################\n\n")
        config_fd.write("# Allow up to 6k concurrent running jobs\n")
        config_fd.write("MAX_JOBS_RUNNING        = 6000\n")
        config_fd.write("# Start 10 jobs every 2 seconds\n")
        config_fd.write("JOB_START_DELAY = 2\n")
        config_fd.write("JOB_START_COUNT = 10\n")
        config_fd.write("# Prevent checking on ImageSize\n")
        config_fd.write("APPEND_REQ_VANILLA = (Memory>=1)\n\n")
        config_fd.write("# Prevent preemption\n")
        config_fd.write("MAXJOBRETIREMENTTIME = $(HOUR) * 24 * 7\n\n")
        config_fd.write("#GCB optimization\n")
        config_fd.write("SCHEDD_SEND_VACATE_VIA_TCP = True\n")
        config_fd.write("STARTD_SENDS_ALIVES = True\n")
    finally:
        config_fd.close()

    MAIN_SCHEDD_INSTALLED=1
    return


# Ask the user if it has PostgreSQL installed
# Install one else
########################################
def query_postgresql():
    global POSTGRESQL_PORT

    while 1:
        yn=raw_input("Do you have already a PostgreSQL installation?: (y/n) ")
        if (yn!="y") and (yn!="n"):
            print "Please answer y or n"
            continue 

        if yn=="y":
            default_port="5432"
            user_port=raw_input("What port is it running on?: [%s] "%default_port)
            if user_port=="":
                user_port=default_port

            # verify the port is registered to postgres
            fd=open("/etc/services","r")
            try:
                lines=fd.readlines()
            finally:
                fd.close()
            found_port=0
            for line in lines:
                if line[:8]=="postgres":
                    if line[8:].find("%s/"%user_port)>=0:
                        found_port=1
                        break
            if not found_port:
                print "Postgres port %s not registered in /etc/services"%user_port
                continue
            
            # found and verified the installation
            POSTGRESQL_PORT=user_port
            return
        else:
            yn=raw_input("Do you want to install the PostgreSQL server?: (y/n) ")
            if (yn!="y"):
                continue # do not install, ask again
            if os.getuid()!=0:
                print "I can only install postgresql as root!"
                continue
            try:
                # install postgreSQL server
                install_postgresql()
            except RuntimeError,e:
                print e
                continue
            return

# Install PostgreSQL server
################################
def install_postgresql():
    global POSTGRESQL_PORT

    if os.getuid()!=0:
        raise RuntimeError, "I can only install postgresql as root!"


    print "Installing PostgreSQL"
    print

    ############################
    # Ask where rpm is running

    print "You must manually download the proper PostgreSQL RPM from the"
    print "official site (http://www.postgresql.org/ftp/binary/)"
    print "You will need the following files:"
    print "  postgresql-*.rpm"
    print "  postgresql-libs-*.rpm"
    print "  postgresql-server-*.rpm"
    print "Version v8.2.4 has been tested, but you should always use the"
    print "latest stable version"
    while 1:
        rpm_fname=raw_input("What is the name of the base PostgreSQL RPM?: ")
        rpm_fname=os.path.abspath(rpm_fname)
        rpm_dir=os.path.dirname(rpm_fname)
        rpm_short_name=os.path.basename(rpm_fname)

        if rpm_short_name[:11]!='postgresql-':
            print "File '%s' not a postgres rpm! (should be something like 'postgresql-8.2.3-1PGDG.i686.rpm'"%rpm_fname
            continue

        # needs 2 more rpms
        rpm2_short_name=rpm_short_name[:11]+'libs-'+rpm_short_name[11:]
        rpm2_fname=os.path.join(rpm_dir,rpm2_short_name)
        rpm3_short_name=rpm_short_name[:11]+'server-'+rpm_short_name[11:]
        rpm3_fname=os.path.join(rpm_dir,rpm3_short_name)


        problems=0
        for f in (rpm_fname,rpm2_fname,rpm3_fname):
            if not os.path.isfile(f):
                print "File '%s' not found!"%f
                problems=1
                break
            err=os.system("rpm -qv -p %s"%f)
            if err!=0:
                print "'%s' is not a valid RPM!"%f
                problems=1
                break
        if problems:
            continue # ask again

        # files found and verified
        break

    ##########################
    # Install the RPM
    print "Installing the PostgreSQL RPM"
    err=os.system("rpm -i %s %s %s"%(rpm_fname,rpm2_fname,rpm3_fname))
    if err!=0:
        raise RuntimeError, "Installation of the RPMs failed!"
    print


    ##########################
    # create the database dir
    def_dir="/var/lib/pgsql/data"
    db_dir=def_dir
    db_dir=create_empty_dir("Where do you want to host the DB data?: ",def_dir)
    os.chmod(db_dir,stat.S_IRWXU)
    os.chown(db_dir,pwd.getpwnam("postgres")[2],pwd.getpwnam("postgres")[3])

    ####################################################
    # The RPM expects it in a standard location
    # Create a symlink is user asked for a different one
    if db_dir!=def_dir:
        if os.path.islink(def_dir):
            os.unlink(def_dir) # remove the old symlink
        elif os.path.exists(def_dir):
            # an old dir exists, rename
            os.rename(def_dir,def_dir+".old_"+time.strftime("%Y%m%d.%H%M"))

        os.symlink(db_dir,def_dir)

    ##########################
    # Initialize it
    print "Initializing PostgreSQL"
    print 'su - postgres -c "initdb -A \'ident sameuser\' -D %s"'%def_dir
    err=os.system('su - postgres -c "initdb -A \'ident sameuser\' -D %s"'%def_dir)
    if err!=0:
        raise RuntimeError, "Initialization of postgresql DB failed!"


    ##########################
    # Select the port
    default_port="5432"
    while 1:
        db_port=raw_input("What port shoud it run on?: [%s] "%default_port)
        if db_port=="":
            db_port=default_port

        # verify the port is registered to postgres
        try:
            db_port_nr=int(db_port)
        except ValueError:
            print "'%s' not a number!"%db_port
            continue
        if (db_port_nr<1) or (db_port_nr>65500):
            print "'%s' out of range!"%db_port
            continue
        #verified
        break

    ##########################
    # Configure network access
    fd=open("/var/lib/pgsql/data/postgresql.conf","a")
    try:
        fd.write("\n###############################################\n")
        fd.write("# Enable connections on all network interfaces \n")
        fd.write("###############################################\n")
        fd.write("listen_addresses = '*'\n\n")
        fd.write("###############################################\n")
        fd.write("# Configure the IP port \n")
        fd.write("###############################################\n")
        fd.write("port = %s\n\n"%db_port)
    finally:
        fd.close()
    
    ##########################
    # Start PostgreSQL
    err=os.system('/etc/init.d/postgresql start')
    if err!=0:
        raise RuntimeError, "Starting of postgresql DB failed!\nSee /var/lib/pgsql/pgstartup.log."


    ######################################
    # Implement a more restrictive policy
    err=os.system('su - postgres -c \'psql -c "REVOKE CREATE ON SCHEMA public FROM PUBLIC;"\'')
    if err!=0:
        raise RuntimeError, "Error restricting postgres DB!"

    err=os.system('su - postgres -c \'psql -d template1 -c "REVOKE CREATE ON SCHEMA public FROM PUBLIC;"\'')
    if err!=0:
        raise RuntimeError, "Error restricting template1 DB!"


    #################################
    # PostgreSQL installed
    print
    print "PostgreSQL installed"
    print
    POSTGRESQL_PORT=db_port
    return

#  
########################################
def get_postgresql_passwd(question,user):
    global POSTGRESQL_PORT
    while 1:
        user_passwd=getpass.getpass(question)

        # this env variable is used instead of stdin
        os.environ['PGPASSWORD']=user_passwd

        # try to connect to postgres and look for passwd auth error
        # (anything else means user does not exist)
        err=os.system('psql -h %s -p %s -U "%s" -d postgres -c "\qecho OK"'%(socket.getfqdn(),POSTGRESQL_PORT,user))
        
        del os.environ['PGPASSWORD']

        if err==0:
            return user_passwd

        print "Wrong password!"


# Verify if quill settings were set 
# Install one else
########################################
def query_quill_db():
    global POSTGRESQL_PORT
    global QUILL_DB_SETUP
    global QUILL_DB_PASSWDS

    ########################################
    # first make sure postgress is installed
    if POSTGRESQL_PORT==None:
        query_postgresql()

    ########################################
    # Check if quill already accounts setup
    ask_confirm=0
    while 1:
        if ask_confirm:
            while raw_input("Have you configured quill accounts?: (y/n) ")!='y':
                pass
        ask_confirm=1 # if I need to try more than one, I should wait for user input

        #set a fake passwd nobody should ever use
        os.environ['PGPASSWORD']='dontuse'

        # try to connect to postgres and look for passwd auth error
        # (anything else means user does not exist)
        quill_users_err={}
        for user in ['quillreader','quillwriter']:
            quill_users_err[user]=os.system('psql -h %s -p %s -U "%s" -d postgres -c "\qecho Enabled" 2>&1 |grep -q "password authentication failed"'%(socket.getfqdn(),POSTGRESQL_PORT,user))
        
        del os.environ['PGPASSWORD']
        
        if (quill_users_err['quillreader']==0) and (quill_users_err['quillreader']==0):
            # already configured, ask for passwd
            reader_passwd=get_postgresql_passwd("Please enter the password used by quill to read from the DB: ",
                                                "quillreader")
            writer_passwd=get_postgresql_passwd("Please enter the password used by quill to update the DB: ",
                                                "quillwriter")
            QUILL_DB_PASSWDS={'reader':reader_passwd,'writer':writer_passwd}
            return
        elif (quill_users_err['quillreader']!=0) and (quill_users_err['quillreader']!=0):
            # not yet configured, do it
            print "Quill accounts not found"
            print
            if os.getuid()==0:
                setup_quill_db()
                return
            else:
                print "I can only configure quill accounts as root!"
        else:
            print "Quill only partially setup! Please fix it before continuing."
            

# Configure the quill settings in DB
####################################
def setup_quill_db():
    global QUILL_DB_PASSWDS
    
    if os.getuid()!=0:
        raise RuntimeError, "I can only setup postgresql quill settings as root!"

    print
    print "Creating Quill accounts in PostgreSQL"
    print

    ##################################
    # get passwords
    reader_passwd=getpass.getpass("Please enter the password used by quill to read from the DB: ")
    writer_passwd=getpass.getpass("Please enter the password used by quill to update the DB: ")

    #########################################
    # Ask how open the read access should be
    deny_ro=raw_input("Deny remote RO access?: (y/n) ")

    ##################################
    # Add quill users in pg_hba.conf
    fd=open("/var/lib/pgsql/data/pg_hba.conf","r+")
    try:
        # read all lines in memory
        lines=fd.readlines()

        # insert the quill accounts

        # find the line to insert it
        # must be before any other config
        # but possibly after the comments
        for i in range(len(lines)):
            line=lines[i]
            if line.find('TYPE'):
                # found the comment line I want to insert after
                i=i+1
                break
            if not line[0] in ('#',' ','\t','\n'):
                # found a config line, insert here (even if not after comments)
                break

        
        lines.insert(i,"\n")
        lines.insert(i+1,"# Condor quill entries\n")
        if deny_ro!="y":
            lines.insert(i+2,"# Allow read from everywhere\n")
            lines.insert(i+3,"host \tall \tquillreader \t0.0.0.0/0 \tmd5\n")
        else:
            lines.insert(i+2,"# Limit read to the local machine\n")
            lines.insert(i+3,"host \tall \tquillreader \t%s/32 \tmd5\n"%socket.gethostbyname(socket.getfqdn()))
            
        lines.insert(i+4,"local \tall \tquillreader \t \tmd5\n")
        lines.insert(i+5,"# Limit writes to the local machine\n")
        lines.insert(i+6,"host \tall \tquillwriter \t%s/32 \tmd5\n"%socket.gethostbyname(socket.getfqdn()))
        lines.insert(i+7,"\n")

        # replace the contents with the new data
        fd.seek(0)
        fd.writelines(lines)
    finally:
        fd.close()
        
    #####################################
    # Tell postgres to reload the config
    err=os.system('/etc/init.d/postgresql reload')
    if err!=0:
        raise RuntimeError, "Error updating PostgreSQL!"

    ##########################################
    # Create and configure the quill accounts
    tmp_fname="/var/lib/pgsql/data/tmp_%s_%s.tmp"%(os.getpid(),time.time())
    fd=open(tmp_fname,"w")
    try:
        fd.write("CREATE USER quillreader NOCREATEDB PASSWORD '%s';\n"%reader_passwd)
        fd.write("CREATE USER quillwriter CREATEDB PASSWORD '%s';\n"%writer_passwd)
        fd.write("REVOKE CREATE ON SCHEMA public FROM PUBLIC;\n")
        fd.write("GRANT CREATE ON SCHEMA public TO quillwriter;\n")
        fd.write("GRANT USAGE ON SCHEMA public TO quillwriter;\n")
    finally:
        fd.close()

    try:
        os.chown(tmp_fname,pwd.getpwnam('postgres')[2],pwd.getpwnam('postgres')[3])

        err=os.system('su - postgres -c "psql -d template1 -f %s"'%tmp_fname)
        if err!=0:
            raise RuntimeError, "Error creating quill accounts!"
    finally:
        os.unlink(tmp_fname)

    err=os.system('su - postgres -c \'psql -c "REVOKE CREATE ON SCHEMA public FROM PUBLIC;"\'')
    if err!=0:
        raise RuntimeError, "Error restricting postgres DB!"


    ################################
    # Configured
    print
    print "Quill accounts setup done"
    print

    QUILL_DB_PASSWDS={'reader':reader_passwd,'writer':writer_passwd}
    return

# Configure Condor quill parameters
####################################
def setup_quill():
    global CONDOR_BASE_PATH
    global QUILL_DB_PASSWDS
    global POSTGRESQL_PORT
    global QUILL_CONFIG_DONE
    global CONDOR_USER
    global CONDOR_UPD_CONFIG_FILE

    if QUILL_DB_PASSWDS==None:
        query_quill_db()

    ################################
    # configure condor parameters
    config_fd=open(CONDOR_UPD_CONFIG_FILE,"a")
    try:
        config_fd.write("\n#############################\n")
        config_fd.write("# Quill settings\n")
        config_fd.write("#############################\n")
        config_fd.write("QUILL_ENABLED = TRUE\n")
        config_fd.write("QUILL_NAME = quill@$(FULL_HOSTNAME)\n")
        config_fd.write("QUILL_DB_NAME = quill\n")
        config_fd.write("QUILL_DB_QUERY_PASSWORD = %s\n"%QUILL_DB_PASSWDS['reader'])
        config_fd.write("QUILL_DB_IP_ADDR = $(HOSTNAME):%s\n"%POSTGRESQL_PORT)
        config_fd.write("QUILL_MANAGE_VACUUM = TRUE\n")
        config_fd.write("# defaults are way to high\n")
        config_fd.write("#in days\nQUILL_HISTORY_DURATION  = 7\n")
        config_fd.write("#in hours\nQUILL_HISTORY_CLEANING_INTERVAL = 6\n")
    finally:
        config_fd.close()

    ######################################
    # create the protected password file
    fd=open("%s/condor_local/spool/.quillwritepassword"%CONDOR_BASE_PATH,"w")
    try:
        fd.write("%s\n"%QUILL_DB_PASSWDS['writer'])
    finally:
        fd.close()
    os.chmod("%s/condor_local/spool/.quillwritepassword"%CONDOR_BASE_PATH,stat.S_IRUSR)
    os.chown("%s/condor_local/spool/.quillwritepassword"%CONDOR_BASE_PATH,
             pwd.getpwnam(CONDOR_USER)[2],pwd.getpwnam(CONDOR_USER)[3])

    QUILL_CONFIG_DONE=1
    return


# Create secondary_schedd_support_files
###############################################
def create_secondary_schedd_support_files():
    global CONDOR_BASE_PATH
    global CONDOR_LOCAL_DIR
    global QUILL_CONFIG_DONE
    global SECONDARY_SCHEDD_SUPPORT_FILES_INSTALLED

    ##############################
    # Secondary schedd setup file
    fd=open("%s/new_schedd_setup.sh"%CONDOR_BASE_PATH,"w")
    try:
        fd.write("if [ $# -ne 1 ]\n")
        fd.write("then\n")
        fd.write(' echo "Schedd name expected!"\n')
        fd.write(" return 1\n")
        fd.write("fi\n\n")
        
        fd.write("LD=%s\n"%CONDOR_LOCAL_DIR)
        if QUILL_CONFIG_DONE:
            fd.write("QDB=quill\n\n")

        fd.write("export _CONDOR_SCHEDD_NAME=schedd_$1\n")
        fd.write("export _CONDOR_MASTER_NAME=${_CONDOR_SCHEDD_NAME}\n")
        fd.write("# SCHEDD and MASTER names MUST be the same (Condor requirement)\n")
        if QUILL_CONFIG_DONE:
            fd.write("export _CONDOR_QUILL_NAME=quill_$1@`uname -n`\n")
            fd.write("export _CONDOR_QUILL_DB_NAME=${QDB}_$1\n")
            fd.write('export _CONDOR_DAEMON_LIST="MASTER,SCHEDD,QUILL"\n')
        else:
            fd.write('export _CONDOR_DAEMON_LIST="MASTER,SCHEDD"\n')
        fd.write("export _CONDOR_LOCAL_DIR=$LD/$_CONDOR_SCHEDD_NAME\n")
        fd.write("export _CONDOR_LOCK=$_CONDOR_LOCAL_DIR/lock\n\n")

        fd.write("unset LD\n")
        if QUILL_CONFIG_DONE:
            fd.write("unset QDB\n")
    finally:
        fd.close()
    os.chmod("%s/new_schedd_setup.sh"%CONDOR_BASE_PATH,
             stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP)

    #######################################
    # Secondary schedd initialization file
    fd=open("%s/init_schedd.sh"%CONDOR_BASE_PATH,"w")
    try:
        fd.write("#!/bin/sh\n")
        fd.write("source %s/new_schedd_setup.sh $1\n"%CONDOR_BASE_PATH)
        fd.write("# add whatever other config you need\n")
        fd.write("# create needed directories\n")
        fd.write("%s/sbin/condor_init\n"%CONDOR_BASE_PATH)
        if QUILL_CONFIG_DONE:
            fd.write("# copy Quill writer passwd\n")
            fd.write("cp -p %s/spool/.quillwritepassword $_CONDOR_LOCAL_DIR/spool/\n"%CONDOR_LOCAL_DIR)
    finally:
        fd.close()
    os.chmod("%s/init_schedd.sh"%CONDOR_BASE_PATH,
             stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

    #######################################
    # Secondary schedd startup file
    fd=open("%s/start_master_schedd.sh"%CONDOR_BASE_PATH,"w")
    try:
        fd.write("#!/bin/sh\n")
        fd.write("source %s/new_schedd_setup.sh $1\n"%CONDOR_BASE_PATH)
        fd.write("# add whatever other config you need\n")
        fd.write("%s/sbin/condor_master\n"%CONDOR_BASE_PATH)
    finally:
        fd.close()
    os.chmod("%s/start_master_schedd.sh"%CONDOR_BASE_PATH,
             stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

    SECONDARY_SCHEDD_SUPPORT_FILES_INSTALLED=1
    return

# Configure the secondary schedds
####################################
def configure_secondary_schedd(schedd_name):
    global CONDOR_BASE_PATH

    err=os.system('%s/init_schedd.sh %s'%(CONDOR_BASE_PATH,schedd_name))
    if err!=0:
        raise RuntimeError, "Failed to initialize schedd '%s'!"%schedd_name

    fd=open("%s/start_condor.sh"%CONDOR_BASE_PATH,"a")
    try:
        fd.write("%s/start_master_schedd.sh %s\n"%(CONDOR_BASE_PATH,schedd_name))
    finally:
        fd.close()

# Ask the user if it has HTTPd installed
# Install one else
########################################
def query_httpd():
    global HTTPD_PORT

    # TO DO
    # Create glideinWMS directory

    while 1:
        yn=raw_input("Do you have already an HTTPd installed?: (y/n) ")
        if (yn!="y") and (yn!="n"):
            print "Please answer y or n"
            continue 

        if yn=="y":
            default_port="80"
            httpd_port=raw_input("What port do you want to use?: [%s] "%default_port)
            if httpd_port=="":
                httpd_port=default_port

            try:
                hc=httplib.HTTPConnection(socket.getfqdn(),httpd_port)
                hc.connect()
                hc.close()
            except:
                print "No httpd found on %s:%s!"%(socket.getfqdn(),httpd_port)
                continue

            # found and verified the installation
            HTTPD_PORT=httpd_port
            return
        else:
            yn=raw_input("Do you want to install a HTTPd?: (y/n) ")
            if (yn!="y"):
                continue # do not install, ask again 
            try:
                install_httpd()
            except RuntimeError, e:
                print e
                continue
            return

# Install a HTTPd
####################################
def install_httpd():
    global HTTPD_PORT

    print
    print "Installing a httpd"
    print

    default_port="80"
    httpd_port=raw_input("What port do you want to use?: [%s] "%default_port)
    if httpd_port=="":
        httpd_port=default_port

    print "Select install method:"
    print " [1] using yum"
    print " [2] using RPMs"
    print " [3] changed my mind, do not install"

    while 1:
        option=raw_input("select: ")
        if option=='1':
            install_yum_httpd()
            break
        elif option=='2':
            install_rpm_httpd()
            break
        elif option=='3':
            raise RuntimeError,"User cancelled the httpd installation"
        else:
            print "Invalid choice '%s'!"%option

    #################################
    # configure port
    fd=open("/etc/httpd/conf/httpd.conf","r")
    try:
        lines=fd.readlines()
    finally:
        fd.close()

    # comment old port and put the correct one
    # also limit modules to the trusted ones
    needed_modules=('access_module','include_module','log_config_module',
                    'mime_magic_module','expires_module','deflate_module',
                    'headers_module','setenvif_module','mime_module',
                    'status_module','autoindex_module','negotiation_module',
                    'dir_module','imap_module','alias_module','rewrite_module',
                    'cache_module','file_cache_module','mem_cache_module',
                    'authz_host_module','authz_default_module')
    
    fd=open("/etc/httpd/conf/httpd.conf","w")
    try:
        for line in lines:
            linearr=line.split()
            if len(linearr)<1:
                fd.write(line) #empty line
            elif linearr[0].lower()=='listen':
                fd.write("#%s"%line)
                fd.write("Listen %s\n"%httpd_port)
            elif linearr[0].lower()=='loadmodule':
                if linearr[1] in needed_modules:
                    fd.write(line)
                else:
                    fd.write("#%s"%line) # disable
            else:
                fd.write(line)
    finally:
        fd.close()

    # disable also all the extensions in conf.d
    fnames=os.listdir('/etc/httpd/conf.d')
    for fname in fnames:
        if fname[-5:]=='.conf':
            os.rename("/etc/httpd/conf.d/%s"%fname,"/etc/httpd/conf.d/%s.org_%s"%(fname,time.strftime("%Y%m%d.%H%M")))

    
    ####################################
    # Create an empty top level page
    if not os.path.exists('/var/www/html/index.html'):
        try:
           fd=open('/var/www/html/index.html',"w")
           try:
               fd.write('<html>\n')
               fd.write('<body>\n')
               fd.write('</body>\n')
               fd.write('</html>\n')
           finally:
               fd.close()
        except:
           pass # the creation of this file is not strictly necessary, so ignore any errors

    ################################
    # start httpd
    err=os.system('/etc/init.d/httpd start')
    if err!=0:
        raise RuntimeError, "Failed to start httpd!"

    print
    print "HTTPd installed on port %s"%httpd_port
    print
    HTTPD_PORT=httpd_port
    return

def install_yum_httpd():
    err=os.system('yum -y install httpd')
    if err!=0:
        raise RuntimeError, "Failed to install httpd via yum!"

    # yum will not complain if it cannot find httpd
    # verify it is installed
    err=os.system('rpm -q --whatprovides httpd')
    if err!=0:
        raise RuntimeError, "HTTPd was not installed by yum!"

    return

def install_rpm_httpd():
    while 1:
        rpm_fname=raw_input("Where do you have the httpd RPM?: ")
        if not os.path.isfile(rpm_fname):
            print "File '%s' not found!"%rpm_fname
            continue
        err=os.system("rpm -qv -p %s"%rpm_fname)
        if err!=0:
            print "'%s' is not a valid RPM!"%rpm_fname
            continue

        # files found and verified
        break

    err=os.system('rpm -i %s'%rpm_fname)
    if err!=0:
        raise RuntimeError, "Failed to install httpd via rpm '%s'!"%rpm_fname

    return

#
# Check if a python module can be imported
###########################################
def check_import(module_name):
    while 1:
        err=os.system("python -c 'import %s'"%module_name)
        if err!=0:
            print "Python module %s not found!"%module_name
            yn=raw_input("Do you want to retry?: (y/n) ")
            if yn!='y':
                raise RuntimeError, "Failed to load %s"%module_name
            continue

        return

# Look for a rrdtool in the path
# Ask the user if there is none
# Install one else
########################################
def query_rrd():
    global RRD_BIN_PATH

    #############################
    # lokk if it is in the path
    fd=os.popen("which rrdtool")
    lines=fd.readlines()
    err=fd.close()
    if err==None: # found
        RRD_BIN_PATH=lines[0][:-1]
        return

    #################################
    # Ask user if it has it installed
    while 1:
        yn=raw_input("Do you have rrd installed?: (y/n) ")
        if yn!="y":
            yn=raw_input("Do you want to install it?: (y/n) ")
            if yn=="y":
                try:
                  return install_rrd()
                except RuntimeError, e:
                  print "%s"%e
            continue # get back to the first question
        #else
        rrd_path=raw_input("In what directory do you have the rrd binary?: ")
        rrd_path=os.path.abspath(rrd_path)

        # Use which to verify the new path
        fd=os.popen("export PATH=$PATH:%s;which rrdtool"%rrd_path)
        lines=fd.readlines()
        err=fd.close()
        if err!=None: # not found
            print "'%s' does not contain rrdtool!"%rrd_path
            continue

        print "rrdtool should be in the path for the glidein factory to properly work"
        yn=raw_input("Do you want to do it now?: (y/n) ")
        if yn=="y":
            ##################################################
            # Put rrd in path
            if os.getuid()==0: # different if root or not
                # as root

                # put rrd binaries in system wide path
                fd=open("/etc/profile.d/rrd.sh","w")
                try:
                    fd.write("if ! echo ${PATH} | grep -q %s/bin ; then\n"%rrd_path)
                    fd.write("  PATH=${PATH}:%s/bin\n"%rrd_path)
                    fd.write("fi\n")
                finally:
                    fd.close()
                os.chmod("/etc/profile.d/rrd.sh",
                         stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)

                fd=open("/etc/profile.d/rrd.csh","w")
                try:
                    fd.write("set path = ( $path %s/bin )\n"%rrd_path)
                finally:
                    fd.close()
                os.chmod("/etc/profile.d/rrd.csh",
                         stat.S_IRWXU|stat.S_IROTH|stat.S_IRGRP|stat.S_IXOTH|stat.S_IXGRP)
            else:
                # as regular user

                # put rrd path in .profile
                fd=open("%s/.profile"%os.environ['HOME'],"a")
                try:
                    fd.write("\n# rrd settings\n")
                    fd.write("if ! echo ${PATH} | grep -q %s/bin ; then\n"%rrd_path)
                    fd.write("  export PATH=${PATH}:%s/bin\n"%rrd_path)
                    fd.write("fi\n\n")
                finally:
                    fd.close()
        
                fd=open("%s/.bashrc"%os.environ['HOME'],"a")
                try:
                    fd.write("\n# rrd settings\n")
                    fd.write("if ! echo ${PATH} | grep -q %s/bin ; then\n"%rrd_path)
                    fd.write("  export PATH=${PATH}:%s/bin\n"%rrd_path)
                    fd.write("fi\n\n")
                finally:
                    fd.close()
        
                # and in .cshrc
                fd=open("%s/.cshrc"%os.environ['HOME'],"a")
                try:
                    fd.write("\n# rrd settings\n")
                    fd.write("set path = ( $path %s/bin )\n"%rrd_path)
                finally:
                    fd.close()

        else:
            print
            print "Remember to put '%s' in the path yourself!"%rrd_path
            print

        RRD_BIN_PATH=rrd_path
        return
    
# Install rrdtool
##########################################
def install_rrd():
    global RRD_BIN_PATH

    print
    print "You will now need the rrdtool RPMs"
    print "You can find them on http://dag.wieers.com/rpm/packages/rrdtool/"
    print "You will need the following RPMs:"
    print "  rrdtool-*.rpm"
    print "  perl-rrdtool-*.rpm"
    print "  python-rrdtool-*.rpm"
    print "Version 1.2.18 has been tested, but you should always use the"
    print "latest one"
    print
    while 1:
        rpm_fname=raw_input("What is the name of the base rrd RPM?: ")
        rpm_fname=os.path.abspath(rpm_fname)
        rpm_dir=os.path.dirname(rpm_fname)
        rpm_short_name=os.path.basename(rpm_fname)

        rpm2_short_name="perl-"+rpm_short_name
        rpm2_fname=os.path.join(rpm_dir,rpm2_short_name)

        rpm3_short_name="python-"+rpm_short_name
        rpm3_fname=os.path.join(rpm_dir,rpm3_short_name)


        problems=0
        for f in (rpm_fname,rpm2_fname,rpm3_fname):
            if not os.path.isfile(f):
                print "File '%s' not found!"%f
                problems=1
                break
            err=os.system("rpm -qv -p %s"%f)
            if err!=0:
                print "'%s' is not a valid RPM!"%f
                problems=1
                break
        if problems:
            continue # ask again

        # files found and verified
        break
        
    ##########################
    # Install the RPM
    print "Installing the rrd RPM"
    err=os.system("rpm -i %s %s %s"%(rpm_fname,rpm2_fname,rpm3_fname))
    if err!=0:
        raise RuntimeError, "Installation of the RPMs failed!"
    print

    return
   
# Get list of GCBs
##########################################
def get_gcb_list():
    print "Please list all the GCB servers you will be using"
    print "Leave an empty line when finished"
    gcb_list=[]
    while 1:
        gcb_entry=raw_input("GCB node: ")
        if gcb_entry=="":
            break # EOF

        try:
            gcb_ip=socket.gethostbyname(gcb_entry)
        except:
            print "'%s' not a valid host name!"%gcb_entry
            continue

        gcb_list.append(gcb_ip)

    return gcb_list


# Compare two entry elements
##########################################

def compare_entry_els(el1,el2):
    for attr in ('gatekeeper','rsl'):
        if el1[attr]!=el2[attr]:
            return False
    return True

# Get list of entry point from RESS
##########################################
def get_ress_glidein_entries(vo,             #vo can be None
                             entries_list,   # disctionary, will add to this
                             config_glexec): # bool, ask for glexec dir
    import condorMonitor

    if config_glexec:
        def_glexec_bin='OSG'
    else:
        def_glexec_bin='NONE'


    default_reqs=""
    if vo!=None:
        default_reqs='StringlistMember("VO:%s",GlueCEAccessControlBaseRule)'%vo

    default_python_filter="(int(GlueCEPolicyMaxCPUTime)==0) or (int(GlueCEPolicyMaxCPUTime)>(72*60))"

    while 1:
        while 1:
            default_ress_url='osg-ress-1.fnal.gov'
            ress_url=raw_input("Which RESS server should I use?: [%s] "%default_ress_url)
            if ress_url=="":
                ress_url=default_ress_url
            try:
                ress_ip=socket.gethostbyname(ress_url)
            except:
                print "'%s' is not a valid host name!"%ress_url
                continue
            #found and verified
            break

    
        select_reqs=raw_input("Select Condor RESS constraint: [%s] "%default_reqs)
        if select_reqs=="":
            select_reqs=default_reqs

        python_filter=raw_input("Define a python filter: [%s] "%default_python_filter)
        if python_filter=="":
            python_filter=default_python_filter
        python_filter_obj=compile(python_filter,"<string>","eval")

        # change defaults in case I need to do it again
        default_reqs=select_reqs
        default_python_filter=python_filter

        # Get gatekeepers from RESS
        ress_constraint='(GlueCEInfoContactString=!=UNDEFINED)&&(%s)'%select_reqs
        condor_obj=condorMonitor.CondorStatus(pool_name=ress_url)
        try:
            condor_obj.load(constraint=ress_constraint)
            condor_data=condor_obj.fetchStored()
        except:
            print "Failed to talk to '%s'"%ress_url
            continue # try again
        del condor_obj
        break # have the data, cont

    cluster_count={}
    ress_entries={}
    for condor_id in condor_data.keys():
        condor_el=condor_data[condor_id]

        if not eval(python_filter_obj,condor_el):
            continue # has not passed the filter

        cluster_name=condor_el['GlueClusterName']
        gatekeeper_name=condor_el['GlueCEInfoContactString']
        rsl='(queue=%s)(jobtype=single)'%condor_el['GlueCEName']
        site_name=condor_el['GlueSiteName']

        work_dir="OSG"
        ress_id={'type':'RESS','server':ress_url,'name':condor_id}
        entry_el={'gatekeeper':gatekeeper_name,'rsl':rsl,'gridtype':'gt2',
                  'work_dir':work_dir,'site_name':site_name,'glexec_path':def_glexec_bin,
                  'is_ids':[ress_id]}

        cluster_arr=cluster_name.split('.')
        if len(cluster_arr)<2:
            continue # something is wrong here, at least a.b expected

        t_found=False
        for t in ress_entries.keys():
            test_el=ress_entries[t]
            if compare_entry_els(test_el,entry_el):
                # found a duplicate entry, just add the additional ress entry to the list
                test_el['is_ids'].append(ress_id)
                t_found=True
                break
        if t_found:
            # found a duplicate entry, see next el
            continue
    
        cluster_id="ress_%s"%site_name

        count=1
        if cluster_count.has_key(cluster_id):
            count=cluster_count[cluster_id]+1
        cluster_count[cluster_id]=count

        if count==1:
            key_name=cluster_id
        else:
            key_name="%s_%i"%(cluster_id,count)

            if count==2: # rename id -> id_1
                key_name_tmp="%s_1"%cluster_id
                ress_entries[key_name_tmp]=ress_entries[cluster_id]
                del ress_entries[cluster_id]

        ress_entries[key_name]=entry_el


    for t in ress_entries.keys():
        test_el=ress_entries[t]
        t_found=False
        for l in entries_list.keys():
            l_el=entries_list[l]
            if compare_entry_els(test_el,l_el):
                # found a duplicate entry
                l_el['is_ids']+=test_el['is_ids']
                del ress_entries[t] # discard the ress_specific entry
                t_found=True
                break

    ress_keys=ress_entries.keys()
    ress_keys.sort()

    print "Found %i additional entries"%len(ress_keys)
    yn=raw_input("Do you want to use them all?: (y/n) ")
    if yn=="y":
        # simply copy all of them
        for key in ress_keys:
            entries_list[key]=ress_entries[key]
        return
    
    print "This is the list of entries found in RESS:"
    for key in ress_keys:
        print "[%s] %s(%s)"%(string.ljust(key,20),ress_entries[key]['gatekeeper'],ress_entries[key]['rsl'])

    print "Select the indexes you want to include"
    print "Use a , separated list to include more than one"
    while 1:
        idxes=raw_input("Please select: ")
        idx_arr=idxes.split(',')
        problems=0
        for idx in idx_arr:
            if not (idx in ress_keys):
                print "'%s' is not a valid index!"%idx
                problems=1
                break
        if problems:
            continue

        # got them
        break

    yn=raw_input("Do you want to customize them?: (y/n) ")
    if yn=="y":
        # customize them
        for idx in idx_arr:
            work_dir=raw_input("Work dir for '%s': [%s] "%(idx,ress_entries[idx]['work_dir']))
            if work_dir!="":
                ress_entries[idx]['work_dir']=work_dir
            site_name=raw_input("Site name for '%s': [%s] "%(idx,ress_entries[idx]['site_name']))
            if site_name!="":
                ress_entries[idx]['site_name']=site_name

        if config_glexec:
            glexec_path=raw_input("gLExec path for '%s': [%s] "%(idx,ress_entries[idx]['glexec_path']))
            if glexec_path!="":
                ress_entries[idx]['glexec_path']=glexec_path
            

    for idx in idx_arr:
        entries_list[idx]=ress_entries[idx]

    return


# Get list of entry point from BDII
##########################################
def get_bdii_glidein_entries(vo,             #vo can be None
                             entries_list,   # dictionary, will add to this
                             config_glexec): # bool, ask for glexec dir
    import ldapMonitor

    if config_glexec:
        def_glexec_bin='/opt/glite/sbin/glexec'
    else:
        def_glexec_bin='NONE'

    while 1:
        default_bdii_url='exp-bdii.cern.ch'
        bdii_url=raw_input("Which BDII server should I use?: [%s] "%default_bdii_url)
        if bdii_url=="":
            bdii_url=default_bdii_url
        try:
            bdii_ip=socket.gethostbyname(bdii_url)
        except:
            print "'%s' is not a valid host name!"%bdii_url
            continue
        #found and verified
        break

    default_reqs=""
    if vo!=None:
        default_reqs='%s(GlueCEAccessControlBaseRule=VO:%s)'%(default_reqs,vo)

    select_reqs=raw_input("Define a BDII LDAP filter: [%s] "%default_reqs)
    if select_reqs=="":
        select_reqs=default_reqs


    default_python_filter="(int(GlueCEPolicyMaxCPUTime)==0) or (int(GlueCEPolicyMaxCPUTime)>(72*60))"
    python_filter=raw_input("Define a python filter: [%s] "%default_python_filter)
    if python_filter=="":
        python_filter=default_python_filter
    python_filter_obj=compile(python_filter,"<string>","eval")

    bdii_obj=ldapMonitor.BDIICEQuery(bdii_url,additional_filter_str=select_reqs)
    bdii_obj.load()
    bdii_data=bdii_obj.fetchStored()
    del bdii_obj

    cluster_count={}
    bdii_entries={}
    for ldap_id in bdii_data.keys():
        el2=bdii_data[ldap_id]

        # LDAP returns everything in lists... convert to values (i.e. get first element from list)
        scalar_el={}
        for k in el2.keys():
            scalar_el[k]=el2[k][0]
        if not eval(python_filter_obj,scalar_el):
            continue # has not passed the filter
        
        work_dir="."
        gatekeeper="%s:%s/jobmanager-%s"%(el2['GlueCEHostingCluster'][0],el2['GlueCEInfoGatekeeperPort'][0],el2['GlueCEInfoJobManager'][0])
        rsl="(queue=%s)(jobtype=single)"%el2['GlueCEName'][0]

        site_name=el2['Mds-Vo-name'][0]
        cluster_id="bdii_%s"%site_name

        bdii_id={'type':'BDII','server':bdii_url,'name':ldap_id}

        count=1
        if cluster_count.has_key(cluster_id):
            count=cluster_count[cluster_id]+1
        cluster_count[cluster_id]=count

        if count==1:
            key_name=cluster_id
        else:
            key_name="%s_%i"%(cluster_id,count)

            if count==2: # rename id -> id_1
                key_name_tmp="%s_1"%cluster_id
                bdii_entries[key_name_tmp]=bdii_entries[cluster_id]
                del bdii_entries[cluster_id]

        guess_glexec_bin=def_glexec_bin
        if guess_glexec_bin!='NONE':
           if el2['GlueCEHostingCluster'][0][-3:] in ('gov','edu'):
             # these should be OSG
             guess_glexec_bin='OSG'
           else:
             # I assume everybody else uses glite software
             guess_glexec_bin='/opt/glite/sbin/glexec'

        bdii_entries[key_name]={'gatekeeper':gatekeeper,'rsl':rsl,'gridtype':'gt2',
                                'work_dir':work_dir,'site_name':site_name,'glexec_path':guess_glexec_bin,
                                'is_ids':[bdii_id]}
        
    for t in bdii_entries.keys():
        test_el=bdii_entries[t]
        t_found=False
        for l in entries_list.keys():
            l_el=entries_list[l]
            if compare_entry_els(test_el,l_el):
                # found a duplicate entry
                l_el['is_ids']+=test_el['is_ids']
                del bdii_entries[t] # discard the bdii_specific entry
                t_found=True
                break

    bdii_keys=bdii_entries.keys()
    bdii_keys.sort()

    print "Found %i additional entries"%len(bdii_keys)
    yn=raw_input("Do you want to use them all?: (y/n) ")
    if yn=="y":
        # simply copy all of them
        for key in bdii_keys:
            entries_list[key]=bdii_entries[key]
        return
    
    print "This is the list of entries found in BDII:"
    for key in bdii_keys:
        print "[%s] %s(%s)"%(string.ljust(key,20),bdii_entries[key]['gatekeeper'],bdii_entries[key]['rsl'])

    print "Select the indexes you want to include"
    print "Use a , separated list to include more than one"
    while 1:
        idxes=raw_input("Please select: ")
        idx_arr=idxes.split(',')
        problems=0
        for idx in idx_arr:
            if not (idx in bdii_keys):
                print "'%s' is not a valid index!"%idx
                problems=1
                break
        if problems:
            continue

        # got them
        break

    yn=raw_input("Do you want to customize them?: (y/n) ")
    if yn=="y":
        # customize them
        for idx in idx_arr:
            work_dir=raw_input("Work dir for '%s': [%s] "%(idx,bdii_entries[idx]['work_dir']))
            if work_dir!="":
                bdii_entries[idx]['work_dir']=work_dir
            site_name=raw_input("Site name for '%s': [%s] "%(idx,bdii_entries[idx]['site_name']))
            if site_name!="":
                bdii_entries[idx]['site_name']=site_name

        if config_glexec:
            glexec_path=raw_input("gLExec path for '%s': [%s] "%(idx,bdii_entries[idx]['glexec_path']))
            if glexec_path!="":
                bdii_entries[idx]['glexec_path']=glexec_path
            

    for idx in idx_arr:
        entries_list[idx]=bdii_entries[idx]

    return

##########################################
if __name__ == '__main__':
    main()

